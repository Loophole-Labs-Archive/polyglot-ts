(string) (len=31931) "\n// Code generated by polyglot-ts v0.4.0, DO NOT EDIT.\n// source: tests.proto\n\n\n\nimport { Kind,decodeArray,decodeBoolean,decodeFloat64,decodeInt32,decodeInt64,decodeMap,decodeString,decodeUint32,encodeArray,encodeBoolean,encodeFloat64,encodeInt32,encodeInt64,encodeMap,encodeString,encodeUint32,} from \"polyglot-ts\"\n\n\nenum Test {\n    Potato = 0,\n    Monkey = 1,\n    }\n\n\n\n\n\n    \n    \n    \n    export class TestAll {\n        constructor(\n        request: Request,\n        response: Response,\n        searchResponse: SearchResponse,\n        stockPricesSuperWrap: StockPricesSuperWrap,\n        ) {\n            this._request = request\n            this._response = response\n            this._searchResponse = searchResponse\n            this._stockPricesSuperWrap = stockPricesSuperWrap\n            }\n\n        private _request: Request\n\n            get request(): Request {\n                return this._request\n            }\n\n            set request(request: Request) {\n                this._request = request\n            }\n            \n        private _response: Response\n\n            get response(): Response {\n                return this._response\n            }\n\n            set response(response: Response) {\n                this._response = response\n            }\n            \n        private _searchResponse: SearchResponse\n\n            get searchResponse(): SearchResponse {\n                return this._searchResponse\n            }\n\n            set searchResponse(searchResponse: SearchResponse) {\n                this._searchResponse = searchResponse\n            }\n            \n        private _stockPricesSuperWrap: StockPricesSuperWrap\n\n            get stockPricesSuperWrap(): StockPricesSuperWrap {\n                return this._stockPricesSuperWrap\n            }\n\n            set stockPricesSuperWrap(stockPricesSuperWrap: StockPricesSuperWrap) {\n                this._stockPricesSuperWrap = stockPricesSuperWrap\n            }\n            \n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n\n        \n    encoded = this._request.encode(encoded);\n        encoded = this._response.encode(encoded);\n        encoded = this._searchResponse.encode(encoded);\n        encoded = this._stockPricesSuperWrap.encode(encoded);\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: TestAll} {\n        let decoded = buf\n        \n        \n            let requestTemp = Request.decode(decoded)\n                decoded = requestTemp.buf\n            \n            let responseTemp = Response.decode(decoded)\n                decoded = responseTemp.buf\n            \n            let searchResponseTemp = SearchResponse.decode(decoded)\n                decoded = searchResponseTemp.buf\n            \n            let stockPricesSuperWrapTemp = StockPricesSuperWrap.decode(decoded)\n                decoded = stockPricesSuperWrapTemp.buf\n            \n\n        return { buf: decoded, value: new TestAll(\n            requestTemp.value,\n            responseTemp.value,\n            searchResponseTemp.value,\n            stockPricesSuperWrapTemp.value,\n            )}\n    }\n\n    } \n\n\n    \n        \nenum RequestCorpus {\n    Universal = 0,\n    Web = 1,\n    Images = 2,\n    Local = 3,\n    News = 4,\n    Products = 5,\n    Video = 6,\n    }\n\n    \n    \n    \n    export class Request {\n        constructor(\n        message: string,\n        corpus: RequestCorpus,\n        ) {\n            this._message = message\n            this._corpus = corpus\n            }\n\n        private _message: string\n\n            get message(): string {\n                return this._message\n            }\n\n            set message(message: string) {\n                this._message = message\n            }\n            \n        private _corpus: RequestCorpus\n\n            get corpus(): RequestCorpus {\n                return this._corpus\n            }\n\n            set corpus(corpus: RequestCorpus) {\n                this._corpus = corpus\n            }\n            \n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n        encoded = encodeString(encoded, this.message)\n        encoded = encodeUint32(encoded, this.corpus as number)\n\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: Request} {\n        let decoded = buf\n        \n        \n            let messageTemp = decodeString(decoded)\n                decoded = messageTemp.buf\n            \n            let corpusU32 = decodeUint32(decoded)\n                const corpusTemp = { value: corpusU32 as RequestCorpus }\n                decoded = corpusU32.buf\n            \n\n        return { buf: decoded, value: new Request(\n            messageTemp.value,\n            corpusTemp.value,\n            )}\n    }\n\n    } \n\n\n    \n    \n    \n    export class Response {\n        constructor(\n        message: string,\n        test: Data,\n        ) {\n            this._message = message\n            this._test = test\n            }\n\n        private _message: string\n\n            get message(): string {\n                return this._message\n            }\n\n            set message(message: string) {\n                this._message = message\n            }\n            \n        private _test: Data\n\n            get test(): Data {\n                return this._test\n            }\n\n            set test(test: Data) {\n                this._test = test\n            }\n            \n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n        encoded = encodeString(encoded, this.message)\n\n        \n    encoded = this._test.encode(encoded);\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: Response} {\n        let decoded = buf\n        \n        \n            let testTemp = Data.decode(decoded)\n                decoded = testTemp.buf\n            \n            let messageTemp = decodeString(decoded)\n                decoded = messageTemp.buf\n            \n\n        return { buf: decoded, value: new Response(\n            messageTemp.value,\n            testTemp.value,\n            )}\n    }\n\n    } \n\n\n    \n    \n    \n    export class Data {\n        constructor(\n        message: string,\n        checker: Test,\n        ) {\n            this._message = message\n            this._checker = checker\n            }\n\n        private _message: string\n\n            get message(): string {\n                return this._message\n            }\n\n            set message(message: string) {\n                this._message = message\n            }\n            \n        private _checker: Test\n\n            get checker(): Test {\n                return this._checker\n            }\n\n            set checker(checker: Test) {\n                this._checker = checker\n            }\n            \n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n        encoded = encodeString(encoded, this.message)\n        encoded = encodeUint32(encoded, this.checker as number)\n\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: Data} {\n        let decoded = buf\n        \n        \n            let messageTemp = decodeString(decoded)\n                decoded = messageTemp.buf\n            \n            let checkerU32 = decodeUint32(decoded)\n                const checkerTemp = { value: checkerU32 as Test }\n                decoded = checkerU32.buf\n            \n\n        return { buf: decoded, value: new Data(\n            messageTemp.value,\n            checkerTemp.value,\n            )}\n    }\n\n    } \n\n\n    \n        \nenum MyMessage1EnumAllowingAlias {\n    UNKNOWN = 0,\n    STARTED = 1,\n    RUNNING = 2,\n    }\n\n    \n    \n    \n    export class MyMessage1 {\n        constructor(\n        ) {\n            }\n\n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: MyMessage1} {\n        let decoded = buf\n        \n        \n\n        return { buf: decoded, value: new MyMessage1(\n            )}\n    }\n\n    } \n\n\n    \n        \nenum MyMessage2EnumNotAllowingAlias {\n    UNKNOWN = 0,\n    STARTED = 1,\n    }\n\n    \n    \n    \n    export class MyMessage2 {\n        constructor(\n        ) {\n            }\n\n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: MyMessage2} {\n        let decoded = buf\n        \n        \n\n        return { buf: decoded, value: new MyMessage2(\n            )}\n    }\n\n    } \n\n\n    \n    \n    \n        \n        \n            \n    \n    export class SearchResponseResult {\n        constructor(\n        url: string,\n        title: string,\n        snippets: string[],\n        ) {\n            this._url = url\n            this._title = title\n            this._snippets = snippets\n            }\n\n        private _url: string\n\n            get url(): string {\n                return this._url\n            }\n\n            set url(url: string) {\n                this._url = url\n            }\n            \n        private _title: string\n\n            get title(): string {\n                return this._title\n            }\n\n            set title(title: string) {\n                this._title = title\n            }\n            \n        private _snippets: string[]\n\n            get snippets(): string[] {\n                return this._snippets\n            }\n\n            set snippets(snippets: string[]) {\n                this._snippets = snippets\n            }\n            \n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n        encoded = encodeString(encoded, this.url)\n        encoded = encodeString(encoded, this.title)\n\n        \n    encoded = encodeArray(this._snippets.length, Kind.String)\n        this._snippets.forEach((field) => {\n            encoded = encodeString(encoded, field)\n        })\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: SearchResponseResult} {\n        let decoded = buf\n        \n        \n            let snippets = decodeArray(decoded)\n            decoded = snippets.buf\n            const snippetsTemp: { value: string[] } = { value: [] }\n            for (let i = 0; i < snippets.size; i++) {\n                let element = decodeString(decoded)\n                    decoded = element.buf\n                snippetsTemp.value.push(element.value)\n            }\n        \n            let urlTemp = decodeString(decoded)\n                decoded = urlTemp.buf\n            \n            let titleTemp = decodeString(decoded)\n                decoded = titleTemp.buf\n            \n\n        return { buf: decoded, value: new SearchResponseResult(\n            urlTemp.value,\n            titleTemp.value,\n            snippetsTemp.value,\n            )}\n    }\n\n    } \n\n        \n    \n    export class SearchResponse {\n        constructor(\n        results: SearchResponseResult[],\n        results2: SearchResponseResult[],\n        snippets: string[],\n        snippets2: string[],\n        ) {\n            this._results = results\n            this._results2 = results2\n            this._snippets = snippets\n            this._snippets2 = snippets2\n            }\n\n        private _results: SearchResponseResult[]\n\n            get results(): SearchResponseResult[] {\n                return this._results\n            }\n\n            set results(results: SearchResponseResult[]) {\n                this._results = results\n            }\n            \n        private _results2: SearchResponseResult[]\n\n            get results2(): SearchResponseResult[] {\n                return this._results2\n            }\n\n            set results2(results2: SearchResponseResult[]) {\n                this._results2 = results2\n            }\n            \n        private _snippets: string[]\n\n            get snippets(): string[] {\n                return this._snippets\n            }\n\n            set snippets(snippets: string[]) {\n                this._snippets = snippets\n            }\n            \n        private _snippets2: string[]\n\n            get snippets2(): string[] {\n                return this._snippets2\n            }\n\n            set snippets2(snippets2: string[]) {\n                this._snippets2 = snippets2\n            }\n            \n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n\n        \n    encoded = encodeArray(encoded, this._results.length, Kind.Any)\n        this._results.forEach((field) => {\n            encoded = field.encode(encoded)\n        })\n        encoded = encodeArray(encoded, this._results2.length, Kind.Any)\n        this._results2.forEach((field) => {\n            encoded = field.encode(encoded)\n        })\n        encoded = encodeArray(this._snippets.length, Kind.String)\n        this._snippets.forEach((field) => {\n            encoded = encodeString(encoded, field)\n        })\n        encoded = encodeArray(this._snippets2.length, Kind.String)\n        this._snippets2.forEach((field) => {\n            encoded = encodeString(encoded, field)\n        })\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: SearchResponse} {\n        let decoded = buf\n        \n        \n            let results = decodeArray(decoded)\n            decoded = results.buf\n            const resultsTemp: { value: SearchResponseResult[] } = { value: [] }\n            for (let i = 0; i < results.size; i++) {\n                let element = SearchResponseResult.decode(decoded)\n                    decoded = element.buf\n                resultsTemp.value.push(element.value)\n            }\n        \n            let results2 = decodeArray(decoded)\n            decoded = results2.buf\n            const results2Temp: { value: SearchResponseResult[] } = { value: [] }\n            for (let i = 0; i < results2.size; i++) {\n                let element = SearchResponseResult.decode(decoded)\n                    decoded = element.buf\n                results2Temp.value.push(element.value)\n            }\n        \n            let snippets = decodeArray(decoded)\n            decoded = snippets.buf\n            const snippetsTemp: { value: string[] } = { value: [] }\n            for (let i = 0; i < snippets.size; i++) {\n                let element = decodeString(decoded)\n                    decoded = element.buf\n                snippetsTemp.value.push(element.value)\n            }\n        \n            let snippets2 = decodeArray(decoded)\n            decoded = snippets2.buf\n            const snippets2Temp: { value: string[] } = { value: [] }\n            for (let i = 0; i < snippets2.size; i++) {\n                let element = decodeString(decoded)\n                    decoded = element.buf\n                snippets2Temp.value.push(element.value)\n            }\n        \n\n        return { buf: decoded, value: new SearchResponse(\n            resultsTemp.value,\n            results2Temp.value,\n            snippetsTemp.value,\n            snippets2Temp.value,\n            )}\n    }\n\n    } \n\n\n    \n    \n    \n    export class Resulting {\n        constructor(\n        url: string,\n        title: string,\n        snippets: string[],\n        ) {\n            this._url = url\n            this._title = title\n            this._snippets = snippets\n            }\n\n        private _url: string\n\n            get url(): string {\n                return this._url\n            }\n\n            set url(url: string) {\n                this._url = url\n            }\n            \n        private _title: string\n\n            get title(): string {\n                return this._title\n            }\n\n            set title(title: string) {\n                this._title = title\n            }\n            \n        private _snippets: string[]\n\n            get snippets(): string[] {\n                return this._snippets\n            }\n\n            set snippets(snippets: string[]) {\n                this._snippets = snippets\n            }\n            \n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n        encoded = encodeString(encoded, this.url)\n        encoded = encodeString(encoded, this.title)\n\n        \n    encoded = encodeArray(this._snippets.length, Kind.String)\n        this._snippets.forEach((field) => {\n            encoded = encodeString(encoded, field)\n        })\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: Resulting} {\n        let decoded = buf\n        \n        \n            let snippets = decodeArray(decoded)\n            decoded = snippets.buf\n            const snippetsTemp: { value: string[] } = { value: [] }\n            for (let i = 0; i < snippets.size; i++) {\n                let element = decodeString(decoded)\n                    decoded = element.buf\n                snippetsTemp.value.push(element.value)\n            }\n        \n            let urlTemp = decodeString(decoded)\n                decoded = urlTemp.buf\n            \n            let titleTemp = decodeString(decoded)\n                decoded = titleTemp.buf\n            \n\n        return { buf: decoded, value: new Resulting(\n            urlTemp.value,\n            titleTemp.value,\n            snippetsTemp.value,\n            )}\n    }\n\n    } \n\n\n    \n    \n    \n    export class SomeOtherMessage {\n        constructor(\n        result: SearchResponseResult,\n        ) {\n            this._result = result\n            }\n\n        private _result: SearchResponseResult\n\n            get result(): SearchResponseResult {\n                return this._result\n            }\n\n            set result(result: SearchResponseResult) {\n                this._result = result\n            }\n            \n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n\n        \n    encoded = this._result.encode(encoded);\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: SomeOtherMessage} {\n        let decoded = buf\n        \n        \n            let resultTemp = SearchResponseResult.decode(decoded)\n                decoded = resultTemp.buf\n            \n\n        return { buf: decoded, value: new SomeOtherMessage(\n            resultTemp.value,\n            )}\n    }\n\n    } \n\n\n    \n    \n    \n        \n        \n            \n    \n        \n        \n            \n    \n    export class OuterMiddleAAInner {\n        constructor(\n        ival: number,\n        booly: boolean,\n        ) {\n            this._ival = ival\n            this._booly = booly\n            }\n\n        private _ival: number\n\n            get ival(): number {\n                return this._ival\n            }\n\n            set ival(ival: number) {\n                this._ival = ival\n            }\n            \n        private _booly: boolean\n\n            get booly(): boolean {\n                return this._booly\n            }\n\n            set booly(booly: boolean) {\n                this._booly = booly\n            }\n            \n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n        encoded = encodeInt64(encoded, this.ival)\n        encoded = encodeBoolean(encoded, this.booly)\n\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: OuterMiddleAAInner} {\n        let decoded = buf\n        \n        \n            let ivalTemp = decodeInt64(decoded)\n                decoded = ivalTemp.buf\n            \n            let boolyTemp = decodeBoolean(decoded)\n                decoded = boolyTemp.buf\n            \n\n        return { buf: decoded, value: new OuterMiddleAAInner(\n            ivalTemp.value,\n            boolyTemp.value,\n            )}\n    }\n\n    } \n\n        \n    \n    export class OuterMiddleAA {\n        constructor(\n        inner: OuterMiddleAAInner,\n        ) {\n            this._inner = inner\n            }\n\n        private _inner: OuterMiddleAAInner\n\n            get inner(): OuterMiddleAAInner {\n                return this._inner\n            }\n\n            set inner(inner: OuterMiddleAAInner) {\n                this._inner = inner\n            }\n            \n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n\n        \n    encoded = this._inner.encode(encoded);\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: OuterMiddleAA} {\n        let decoded = buf\n        \n        \n            let innerTemp = OuterMiddleAAInner.decode(decoded)\n                decoded = innerTemp.buf\n            \n\n        return { buf: decoded, value: new OuterMiddleAA(\n            innerTemp.value,\n            )}\n    }\n\n    } \n\n        \n    \n        \n        \n            \n    \n        \n        \n            \n    \n    export class OuterMiddleBBInner {\n        constructor(\n        ival: number,\n        booly: boolean,\n        ) {\n            this._ival = ival\n            this._booly = booly\n            }\n\n        private _ival: number\n\n            get ival(): number {\n                return this._ival\n            }\n\n            set ival(ival: number) {\n                this._ival = ival\n            }\n            \n        private _booly: boolean\n\n            get booly(): boolean {\n                return this._booly\n            }\n\n            set booly(booly: boolean) {\n                this._booly = booly\n            }\n            \n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n        encoded = encodeInt32(encoded, this.ival)\n        encoded = encodeBoolean(encoded, this.booly)\n\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: OuterMiddleBBInner} {\n        let decoded = buf\n        \n        \n            let ivalTemp = decodeInt32(decoded)\n                decoded = ivalTemp.buf\n            \n            let boolyTemp = decodeBoolean(decoded)\n                decoded = boolyTemp.buf\n            \n\n        return { buf: decoded, value: new OuterMiddleBBInner(\n            ivalTemp.value,\n            boolyTemp.value,\n            )}\n    }\n\n    } \n\n        \n    \n    export class OuterMiddleBB {\n        constructor(\n        inner: OuterMiddleBBInner,\n        ) {\n            this._inner = inner\n            }\n\n        private _inner: OuterMiddleBBInner\n\n            get inner(): OuterMiddleBBInner {\n                return this._inner\n            }\n\n            set inner(inner: OuterMiddleBBInner) {\n                this._inner = inner\n            }\n            \n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n\n        \n    encoded = this._inner.encode(encoded);\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: OuterMiddleBB} {\n        let decoded = buf\n        \n        \n            let innerTemp = OuterMiddleBBInner.decode(decoded)\n                decoded = innerTemp.buf\n            \n\n        return { buf: decoded, value: new OuterMiddleBB(\n            innerTemp.value,\n            )}\n    }\n\n    } \n\n        \n    \n    export class Outer {\n        constructor(\n        a: OuterMiddleAA,\n        b: OuterMiddleBB,\n        ) {\n            this._a = a\n            this._b = b\n            }\n\n        private _a: OuterMiddleAA\n\n            get a(): OuterMiddleAA {\n                return this._a\n            }\n\n            set a(a: OuterMiddleAA) {\n                this._a = a\n            }\n            \n        private _b: OuterMiddleBB\n\n            get b(): OuterMiddleBB {\n                return this._b\n            }\n\n            set b(b: OuterMiddleBB) {\n                this._b = b\n            }\n            \n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n\n        \n    encoded = this._a.encode(encoded);\n        encoded = this._b.encode(encoded);\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: Outer} {\n        let decoded = buf\n        \n        \n            let aTemp = OuterMiddleAA.decode(decoded)\n                decoded = aTemp.buf\n            \n            let bTemp = OuterMiddleBB.decode(decoded)\n                decoded = bTemp.buf\n            \n\n        return { buf: decoded, value: new Outer(\n            aTemp.value,\n            bTemp.value,\n            )}\n    }\n\n    } \n\n\n    \n    \n    \n    export class SampleMessage {\n        constructor(\n        name: string,\n        potato: string,\n        ) {\n            this._name = name\n            this._potato = potato\n            }\n\n        private _name: string\n\n            get name(): string {\n                return this._name\n            }\n\n            set name(name: string) {\n                this._name = name\n            }\n            \n        private _potato: string\n\n            get potato(): string {\n                return this._potato\n            }\n\n            set potato(potato: string) {\n                this._potato = potato\n            }\n            \n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n        encoded = encodeString(encoded, this.name)\n        encoded = encodeString(encoded, this.potato)\n\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: SampleMessage} {\n        let decoded = buf\n        \n        \n            let nameTemp = decodeString(decoded)\n                decoded = nameTemp.buf\n            \n            let potatoTemp = decodeString(decoded)\n                decoded = potatoTemp.buf\n            \n\n        return { buf: decoded, value: new SampleMessage(\n            nameTemp.value,\n            potatoTemp.value,\n            )}\n    }\n\n    } \n\n\n    \n    \n    \n        \n        \n    \n    export class TestPotato {\n        constructor(\n        prices: Map<string, Test>,\n        ) {\n            this._prices = prices\n            }\n\n        private _prices: Map<string, Test>\n\n            get prices(): Map<string, Test> {\n                return this._prices\n            }\n\n            set prices(prices: Map<string, Test>) {\n                this._prices = prices\n            }\n            \n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n\n        \n    encoded = encodeMap(encoded, this._prices.size, Kind.String, Kind.U32)\n            this._prices.forEach((v, k) => {\n            encoded = encodeString(encoded, k)\n                encoded = encodeUint32(encoded, v as number)\n                })\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: TestPotato} {\n        let decoded = buf\n        \n        \n            \n\n\nlet prices = decodeMap(decoded)\ndecoded = prices.buf\nconst pricesTemp: { value: Map<string,Test> } = { value: new Map() }\nfor (let i = 0; i < prices.size; i++) {\n    let key = decodeString(decoded)\n        decoded = key.buf\n    \n\n    let valueEnum = decodeUint32(decoded)\n        const value = { value: valueEnum as Test }\n        decoded = valueEnum.buf\n    \n\n    prices.value.set(key, value)\n}\n\n\n        return { buf: decoded, value: new TestPotato(\n            pricesTemp.value,\n            )}\n    }\n\n    } \n\n\n    \n    \n    \n        \n        \n    \n    export class StockPrices {\n        constructor(\n        prices: Map<string, number>,\n        ) {\n            this._prices = prices\n            }\n\n        private _prices: Map<string, number>\n\n            get prices(): Map<string, number> {\n                return this._prices\n            }\n\n            set prices(prices: Map<string, number>) {\n                this._prices = prices\n            }\n            \n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n\n        \n    encoded = encodeMap(encoded, this._prices.size, Kind.String, Kind.F64)\n            this._prices.forEach((v, k) => {\n            encoded = encodeString(encoded, k)\n                encoded = encodeFloat64(encoded, v)\n                })\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: StockPrices} {\n        let decoded = buf\n        \n        \n            \n\n\nlet prices = decodeMap(decoded)\ndecoded = prices.buf\nconst pricesTemp: { value: Map<string,number> } = { value: new Map() }\nfor (let i = 0; i < prices.size; i++) {\n    let key = decodeString(decoded)\n        decoded = key.buf\n    \n\n    let value = decodeFloat64(decoded)\n        decoded = value.buf\n    \n\n    prices.value.set(key, value)\n}\n\n\n        return { buf: decoded, value: new StockPrices(\n            pricesTemp.value,\n            )}\n    }\n\n    } \n\n\n    \n    \n    \n    export class StockPricesWrapper {\n        constructor(\n        sPrices: StockPrices[],\n        ) {\n            this._sPrices = sPrices\n            }\n\n        private _sPrices: StockPrices[]\n\n            get sPrices(): StockPrices[] {\n                return this._sPrices\n            }\n\n            set sPrices(sPrices: StockPrices[]) {\n                this._sPrices = sPrices\n            }\n            \n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n\n        \n    encoded = encodeArray(encoded, this._sPrices.length, Kind.Any)\n        this._sPrices.forEach((field) => {\n            encoded = field.encode(encoded)\n        })\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: StockPricesWrapper} {\n        let decoded = buf\n        \n        \n            let sPrices = decodeArray(decoded)\n            decoded = sPrices.buf\n            const sPricesTemp: { value: StockPrices[] } = { value: [] }\n            for (let i = 0; i < sPrices.size; i++) {\n                let element = StockPrices.decode(decoded)\n                    decoded = element.buf\n                sPricesTemp.value.push(element.value)\n            }\n        \n\n        return { buf: decoded, value: new StockPricesWrapper(\n            sPricesTemp.value,\n            )}\n    }\n\n    } \n\n\n    \n    \n    \n        \n        \n    \n    export class StockPricesSuperWrap {\n        constructor(\n        prices: Map<string, StockPricesWrapper>,\n        ) {\n            this._prices = prices\n            }\n\n        private _prices: Map<string, StockPricesWrapper>\n\n            get prices(): Map<string, StockPricesWrapper> {\n                return this._prices\n            }\n\n            set prices(prices: Map<string, StockPricesWrapper>) {\n                this._prices = prices\n            }\n            \n        \n    encode(buf: Uint8Array): Uint8Array {\n        let encoded = buf\n        \n        \n\n        \n    encoded = encodeMap(encoded, this._prices.size, Kind.String, Kind.Any)\n            this._prices.forEach((v, k) => {\n            encoded = encodeString(encoded, k)\n                encoded = v.encode(encoded)\n            })\n        \n        \n        return encoded\n    }\n\n\n        \n    static decode(buf: Uint8Array): { buf: Uint8Array, value: StockPricesSuperWrap} {\n        let decoded = buf\n        \n        \n            \n\n\nlet prices = decodeMap(decoded)\ndecoded = prices.buf\nconst pricesTemp: { value: Map<string,StockPricesWrapper> } = { value: new Map() }\nfor (let i = 0; i < prices.size; i++) {\n    let key = decodeString(decoded)\n        decoded = key.buf\n    \n\n    let value = StockPricesWrapper.decode(decoded)\n        decoded = value.buf\n    \n\n    prices.value.set(key, value)\n}\n\n\n        return { buf: decoded, value: new StockPricesSuperWrap(\n            pricesTemp.value,\n            )}\n    }\n\n    } \n\n\n\n"
