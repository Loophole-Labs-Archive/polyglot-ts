// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Generator Can generate TypeScript for array.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt32, decodeInt32, encodeArray, Kind, decodeArray } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace array {
                        export class ExampleMessage {
                            constructor(name: string, addresses: string[], balances: number[]) {
                                this._name = name
                                this._addresses = addresses
                                this._balances = balances
                            }

                            private _name: string;

                            get name(): string {
                                return this._name
                            }

                            set name(name: string) {
                                this._name = name
                            }

                            private _addresses: string[];

                            get addresses(): string[] {
                                return this._addresses
                            }

                            set addresses(addresses: string[]) {
                                this._addresses = addresses
                            }

                            private _balances: number[];

                            get balances(): number[] {
                                return this._balances
                            }

                            set balances(balances: number[]) {
                                this._balances = balances
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._name)
                                encoded = encodeArray(encoded, this._addresses.length, Kind.String)
                                this._addresses.forEach(field => {
                                                  encoded = encodeString(encoded, field);
                                                })
                                encoded = encodeArray(encoded, this._balances.length, Kind.Int32)
                                this._balances.forEach(field => {
                                                  encoded = encodeInt32(encoded, field);
                                                })
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: ExampleMessage
                                    } {
                                let decoded = buf
                                const name = decodeString(decoded)
                                decoded = name.buf
                                const addressesArray = decodeArray(decoded)
                                decoded = addressesArray.buf
                                const addresses: { value: string[] } = {
                                                  value: [],
                                                }

                                for (let i = 0; i < addressesArray.size; i++) {
                                                  const element = decodeString(decoded);
                                                  decoded = element.buf;
                                                  addresses.value.push(element.value);
                                                }

                                const balancesArray = decodeArray(decoded)
                                decoded = balancesArray.buf
                                const balances: { value: number[] } = {
                                                  value: [],
                                                }

                                for (let i = 0; i < balancesArray.size; i++) {
                                                  const element = decodeInt32(decoded);
                                                  decoded = element.buf;
                                                  balances.value.push(element.value);
                                                }

                                return {
                                      buf: decoded,
                                      value: new ExampleMessage(name.value,addresses.value,balances.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for array_composite.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt32, decodeInt32, encodeArray, Kind, decodeArray } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace array {
                        export namespace composite {
                            export class ExampleMessage {
                                constructor(name: string, addresses: string[], patients: NestedExampleMessage[]) {
                                    this._name = name
                                    this._addresses = addresses
                                    this._patients = patients
                                }

                                private _name: string;

                                get name(): string {
                                    return this._name
                                }

                                set name(name: string) {
                                    this._name = name
                                }

                                private _addresses: string[];

                                get addresses(): string[] {
                                    return this._addresses
                                }

                                set addresses(addresses: string[]) {
                                    this._addresses = addresses
                                }

                                private _patients: NestedExampleMessage[];

                                get patients(): NestedExampleMessage[] {
                                    return this._patients
                                }

                                set patients(patients: NestedExampleMessage[]) {
                                    this._patients = patients
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeString(encoded, this._name)
                                    encoded = encodeArray(encoded, this._addresses.length, Kind.String)
                                    this._addresses.forEach(field => {
                                                      encoded = encodeString(encoded, field);
                                                    })
                                    encoded = encodeArray(encoded, this._patients.length, Kind.Any)
                                    this._patients.forEach((field) => {
                                                      encoded = field.encode(encoded);
                                                    })
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: ExampleMessage
                                        } {
                                    let decoded = buf
                                    const name = decodeString(decoded)
                                    decoded = name.buf
                                    const addressesArray = decodeArray(decoded)
                                    decoded = addressesArray.buf
                                    const addresses: { value: string[] } = {
                                                      value: [],
                                                    }

                                    for (let i = 0; i < addressesArray.size; i++) {
                                                      const element = decodeString(decoded);
                                                      decoded = element.buf;
                                                      addresses.value.push(element.value);
                                                    }

                                    const patientsArray = decodeArray(decoded)
                                    decoded = patientsArray.buf
                                    const patients: { value: NestedExampleMessage[] } = {
                                                      value: [],
                                                    }

                                    for (let i = 0; i < patientsArray.size; i++) {
                                                      const element = NestedExampleMessage.decode(decoded);
                                                      decoded = element.buf;
                                                      patients.value.push(element.value);
                                                    }

                                    return {
                                          buf: decoded,
                                          value: new ExampleMessage(name.value,addresses.value,patients.value)
                                        }
                                }
                            }

                            export class NestedExampleMessage {
                                constructor(age: number) {
                                    this._age = age
                                }

                                private _age: number;

                                get age(): number {
                                    return this._age
                                }

                                set age(age: number) {
                                    this._age = age
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeInt32(encoded, this._age)
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: NestedExampleMessage
                                        } {
                                    let decoded = buf
                                    const age = decodeInt32(decoded)
                                    decoded = age.buf
                                    return {
                                          buf: decoded,
                                          value: new NestedExampleMessage(age.value)
                                        }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for array_enum.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString, encodeArray, Kind, encodeUint8, decodeArray, decodeUint8 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace array {
                        export namespace enm {
                            enum MessageType {
                                MESSAGE_TYPE_A = 0,
                                MESSAGE_TYPE_B = 1,
                                MESSAGE_TYPE_C = 2
                            }

                            export class ExampleMessage {
                                constructor(name: string, addresses: string[], patients: MessageType[]) {
                                    this._name = name
                                    this._addresses = addresses
                                    this._patients = patients
                                }

                                private _name: string;

                                get name(): string {
                                    return this._name
                                }

                                set name(name: string) {
                                    this._name = name
                                }

                                private _addresses: string[];

                                get addresses(): string[] {
                                    return this._addresses
                                }

                                set addresses(addresses: string[]) {
                                    this._addresses = addresses
                                }

                                private _patients: MessageType[];

                                get patients(): MessageType[] {
                                    return this._patients
                                }

                                set patients(patients: MessageType[]) {
                                    this._patients = patients
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeString(encoded, this._name)
                                    encoded = encodeArray(encoded, this._addresses.length, Kind.String)
                                    this._addresses.forEach(field => {
                                                      encoded = encodeString(encoded, field);
                                                    })
                                    encoded = encodeArray(encoded, this._patients.length, Kind.Any)
                                    this._patients.forEach(field => {
                                                      encoded = encodeUint8(encoded, field as number);
                                                    })
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: ExampleMessage
                                        } {
                                    let decoded = buf
                                    const name = decodeString(decoded)
                                    decoded = name.buf
                                    const addressesArray = decodeArray(decoded)
                                    decoded = addressesArray.buf
                                    const addresses: { value: string[] } = {
                                                      value: [],
                                                    }

                                    for (let i = 0; i < addressesArray.size; i++) {
                                                      const element = decodeString(decoded);
                                                      decoded = element.buf;
                                                      addresses.value.push(element.value);
                                                    }

                                    const patientsArray = decodeArray(decoded)
                                    decoded = patientsArray.buf
                                    const patients: { value: MessageType[] } = {
                                                      value: [],
                                                    }

                                    for (let i = 0; i < patientsArray.size; i++) {
                                                      const element = decodeUint8(decoded);
                                                      decoded = element.buf;
                                                      patients.value.push(element.value as MessageType);
                                                    }

                                    return {
                                          buf: decoded,
                                          value: new ExampleMessage(name.value,addresses.value,patients.value)
                                        }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for complete.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt64, decodeInt64, encodeBoolean, decodeBoolean, encodeInt32, decodeInt32, encodeFloat64, decodeFloat64, encodeUint8, decodeUint8, encodeArray, Kind, decodeArray, encodeMap, decodeMap } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace complete {
                    enum RequestCorpus {
                        UNIVERSAL = 0,
                        WEB = 1,
                        IMAGES = 2,
                        LOCAL = 3,
                        NEWS = 4,
                        PRODUCTS = 5,
                        VIDEO = 6
                    }

                    enum Test {
                        Potato = 0,
                        Monkey = 1
                    }

                    enum MyMessage1EnumAllowingAlias {
                        UNKNOWN = 0,
                        STARTED = 1,
                        RUNNING = 2
                    }

                    enum MyMessage2EnumNotAllowingAlias {
                        UNKNOWN = 0,
                        STARTED = 1
                    }

                    export class Request {
                        constructor(Message: string, corpus: RequestCorpus) {
                            this._Message = Message
                            this._corpus = corpus
                        }

                        private _Message: string;

                        get Message(): string {
                            return this._Message
                        }

                        set Message(Message: string) {
                            this._Message = Message
                        }

                        private _corpus: RequestCorpus;

                        get corpus(): RequestCorpus {
                            return this._corpus
                        }

                        set corpus(corpus: RequestCorpus) {
                            this._corpus = corpus
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeString(encoded, this._Message)
                            encoded = encodeUint8(encoded, this._corpus as number)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: Request
                                } {
                            let decoded = buf
                            const Message = decodeString(decoded)
                            decoded = Message.buf
                            const corpusUint8 = decodeUint8(decoded)
                            const corpus = { value: corpusUint8.value as RequestCorpus }

                            decoded = corpusUint8.buf
                            return {
                                  buf: decoded,
                                  value: new Request(Message.value,corpus.value)
                                }
                        }
                    }

                    export class Response {
                        constructor(Message: string, Test: Data) {
                            this._Message = Message
                            this._Test = Test
                        }

                        private _Message: string;

                        get Message(): string {
                            return this._Message
                        }

                        set Message(Message: string) {
                            this._Message = Message
                        }

                        private _Test: Data;

                        get Test(): Data {
                            return this._Test
                        }

                        set Test(Test: Data) {
                            this._Test = Test
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeString(encoded, this._Message)
                            encoded = this._Test.encode(encoded)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: Response
                                } {
                            let decoded = buf
                            const Message = decodeString(decoded)
                            decoded = Message.buf
                            const Test = Data.decode(decoded)
                            decoded = Test.buf
                            return {
                                  buf: decoded,
                                  value: new Response(Message.value,Test.value)
                                }
                        }
                    }

                    export class Data {
                        constructor(Message: string, Checker: Test) {
                            this._Message = Message
                            this._Checker = Checker
                        }

                        private _Message: string;

                        get Message(): string {
                            return this._Message
                        }

                        set Message(Message: string) {
                            this._Message = Message
                        }

                        private _Checker: Test;

                        get Checker(): Test {
                            return this._Checker
                        }

                        set Checker(Checker: Test) {
                            this._Checker = Checker
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeString(encoded, this._Message)
                            encoded = encodeUint8(encoded, this._Checker as number)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: Data
                                } {
                            let decoded = buf
                            const Message = decodeString(decoded)
                            decoded = Message.buf
                            const CheckerUint8 = decodeUint8(decoded)
                            const Checker = { value: CheckerUint8.value as Test }

                            decoded = CheckerUint8.buf
                            return {
                                  buf: decoded,
                                  value: new Data(Message.value,Checker.value)
                                }
                        }
                    }

                    export class MyMessage1 {
                        constructor() {
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: MyMessage1
                                } {
                            let decoded = buf
                            return {
                                  buf: decoded,
                                  value: new MyMessage1()
                                }
                        }
                    }

                    export class MyMessage2 {
                        constructor() {
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: MyMessage2
                                } {
                            let decoded = buf
                            return {
                                  buf: decoded,
                                  value: new MyMessage2()
                                }
                        }
                    }

                    export class SearchResponse {
                        constructor(results: SearchResponseResult[], results2: SearchResponseResult[], snippets: string[], snippets2: string[]) {
                            this._results = results
                            this._results2 = results2
                            this._snippets = snippets
                            this._snippets2 = snippets2
                        }

                        private _results: SearchResponseResult[];

                        get results(): SearchResponseResult[] {
                            return this._results
                        }

                        set results(results: SearchResponseResult[]) {
                            this._results = results
                        }

                        private _results2: SearchResponseResult[];

                        get results2(): SearchResponseResult[] {
                            return this._results2
                        }

                        set results2(results2: SearchResponseResult[]) {
                            this._results2 = results2
                        }

                        private _snippets: string[];

                        get snippets(): string[] {
                            return this._snippets
                        }

                        set snippets(snippets: string[]) {
                            this._snippets = snippets
                        }

                        private _snippets2: string[];

                        get snippets2(): string[] {
                            return this._snippets2
                        }

                        set snippets2(snippets2: string[]) {
                            this._snippets2 = snippets2
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeArray(encoded, this._results.length, Kind.Any)
                            this._results.forEach((field) => {
                                              encoded = field.encode(encoded);
                                            })
                            encoded = encodeArray(encoded, this._results2.length, Kind.Any)
                            this._results2.forEach((field) => {
                                              encoded = field.encode(encoded);
                                            })
                            encoded = encodeArray(encoded, this._snippets.length, Kind.String)
                            this._snippets.forEach(field => {
                                              encoded = encodeString(encoded, field);
                                            })
                            encoded = encodeArray(encoded, this._snippets2.length, Kind.String)
                            this._snippets2.forEach(field => {
                                              encoded = encodeString(encoded, field);
                                            })
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: SearchResponse
                                } {
                            let decoded = buf
                            const resultsArray = decodeArray(decoded)
                            decoded = resultsArray.buf
                            const results: { value: SearchResponseResult[] } = {
                                              value: [],
                                            }

                            for (let i = 0; i < resultsArray.size; i++) {
                                              const element = SearchResponseResult.decode(decoded);
                                              decoded = element.buf;
                                              results.value.push(element.value);
                                            }

                            const results2Array = decodeArray(decoded)
                            decoded = results2Array.buf
                            const results2: { value: SearchResponseResult[] } = {
                                              value: [],
                                            }

                            for (let i = 0; i < results2Array.size; i++) {
                                              const element = SearchResponseResult.decode(decoded);
                                              decoded = element.buf;
                                              results2.value.push(element.value);
                                            }

                            const snippetsArray = decodeArray(decoded)
                            decoded = snippetsArray.buf
                            const snippets: { value: string[] } = {
                                              value: [],
                                            }

                            for (let i = 0; i < snippetsArray.size; i++) {
                                              const element = decodeString(decoded);
                                              decoded = element.buf;
                                              snippets.value.push(element.value);
                                            }

                            const snippets2Array = decodeArray(decoded)
                            decoded = snippets2Array.buf
                            const snippets2: { value: string[] } = {
                                              value: [],
                                            }

                            for (let i = 0; i < snippets2Array.size; i++) {
                                              const element = decodeString(decoded);
                                              decoded = element.buf;
                                              snippets2.value.push(element.value);
                                            }

                            return {
                                  buf: decoded,
                                  value: new SearchResponse(results.value,results2.value,snippets.value,snippets2.value)
                                }
                        }
                    }

                    export class SearchResponseResult {
                        constructor(url: string, title: string, snippets: string[]) {
                            this._url = url
                            this._title = title
                            this._snippets = snippets
                        }

                        private _url: string;

                        get url(): string {
                            return this._url
                        }

                        set url(url: string) {
                            this._url = url
                        }

                        private _title: string;

                        get title(): string {
                            return this._title
                        }

                        set title(title: string) {
                            this._title = title
                        }

                        private _snippets: string[];

                        get snippets(): string[] {
                            return this._snippets
                        }

                        set snippets(snippets: string[]) {
                            this._snippets = snippets
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeString(encoded, this._url)
                            encoded = encodeString(encoded, this._title)
                            encoded = encodeArray(encoded, this._snippets.length, Kind.String)
                            this._snippets.forEach(field => {
                                              encoded = encodeString(encoded, field);
                                            })
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: SearchResponseResult
                                } {
                            let decoded = buf
                            const url = decodeString(decoded)
                            decoded = url.buf
                            const title = decodeString(decoded)
                            decoded = title.buf
                            const snippetsArray = decodeArray(decoded)
                            decoded = snippetsArray.buf
                            const snippets: { value: string[] } = {
                                              value: [],
                                            }

                            for (let i = 0; i < snippetsArray.size; i++) {
                                              const element = decodeString(decoded);
                                              decoded = element.buf;
                                              snippets.value.push(element.value);
                                            }

                            return {
                                  buf: decoded,
                                  value: new SearchResponseResult(url.value,title.value,snippets.value)
                                }
                        }
                    }

                    export class Resulting {
                        constructor(url: string, title: string, snippets: string[]) {
                            this._url = url
                            this._title = title
                            this._snippets = snippets
                        }

                        private _url: string;

                        get url(): string {
                            return this._url
                        }

                        set url(url: string) {
                            this._url = url
                        }

                        private _title: string;

                        get title(): string {
                            return this._title
                        }

                        set title(title: string) {
                            this._title = title
                        }

                        private _snippets: string[];

                        get snippets(): string[] {
                            return this._snippets
                        }

                        set snippets(snippets: string[]) {
                            this._snippets = snippets
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeString(encoded, this._url)
                            encoded = encodeString(encoded, this._title)
                            encoded = encodeArray(encoded, this._snippets.length, Kind.String)
                            this._snippets.forEach(field => {
                                              encoded = encodeString(encoded, field);
                                            })
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: Resulting
                                } {
                            let decoded = buf
                            const url = decodeString(decoded)
                            decoded = url.buf
                            const title = decodeString(decoded)
                            decoded = title.buf
                            const snippetsArray = decodeArray(decoded)
                            decoded = snippetsArray.buf
                            const snippets: { value: string[] } = {
                                              value: [],
                                            }

                            for (let i = 0; i < snippetsArray.size; i++) {
                                              const element = decodeString(decoded);
                                              decoded = element.buf;
                                              snippets.value.push(element.value);
                                            }

                            return {
                                  buf: decoded,
                                  value: new Resulting(url.value,title.value,snippets.value)
                                }
                        }
                    }

                    export class SomeOtherMessage {
                        constructor(result: SearchResponseResult) {
                            this._result = result
                        }

                        private _result: SearchResponseResult;

                        get result(): SearchResponseResult {
                            return this._result
                        }

                        set result(result: SearchResponseResult) {
                            this._result = result
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = this._result.encode(encoded)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: SomeOtherMessage
                                } {
                            let decoded = buf
                            const result = SearchResponseResult.decode(decoded)
                            decoded = result.buf
                            return {
                                  buf: decoded,
                                  value: new SomeOtherMessage(result.value)
                                }
                        }
                    }

                    export class Outer {
                        constructor(a: OuterMiddleAA, b: OuterMiddleBB) {
                            this._a = a
                            this._b = b
                        }

                        private _a: OuterMiddleAA;

                        get a(): OuterMiddleAA {
                            return this._a
                        }

                        set a(a: OuterMiddleAA) {
                            this._a = a
                        }

                        private _b: OuterMiddleBB;

                        get b(): OuterMiddleBB {
                            return this._b
                        }

                        set b(b: OuterMiddleBB) {
                            this._b = b
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = this._a.encode(encoded)
                            encoded = this._b.encode(encoded)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: Outer
                                } {
                            let decoded = buf
                            const a = OuterMiddleAA.decode(decoded)
                            decoded = a.buf
                            const b = OuterMiddleBB.decode(decoded)
                            decoded = b.buf
                            return {
                                  buf: decoded,
                                  value: new Outer(a.value,b.value)
                                }
                        }
                    }

                    export class OuterMiddleAA {
                        constructor(inner: OuterMiddleAAInner) {
                            this._inner = inner
                        }

                        private _inner: OuterMiddleAAInner;

                        get inner(): OuterMiddleAAInner {
                            return this._inner
                        }

                        set inner(inner: OuterMiddleAAInner) {
                            this._inner = inner
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = this._inner.encode(encoded)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: OuterMiddleAA
                                } {
                            let decoded = buf
                            const inner = OuterMiddleAAInner.decode(decoded)
                            decoded = inner.buf
                            return {
                                  buf: decoded,
                                  value: new OuterMiddleAA(inner.value)
                                }
                        }
                    }

                    export class OuterMiddleAAInner {
                        constructor(ival: bigint, booly: boolean) {
                            this._ival = ival
                            this._booly = booly
                        }

                        private _ival: bigint;

                        get ival(): bigint {
                            return this._ival
                        }

                        set ival(ival: bigint) {
                            this._ival = ival
                        }

                        private _booly: boolean;

                        get booly(): boolean {
                            return this._booly
                        }

                        set booly(booly: boolean) {
                            this._booly = booly
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeInt64(encoded, this._ival)
                            encoded = encodeBoolean(encoded, this._booly)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: OuterMiddleAAInner
                                } {
                            let decoded = buf
                            const ival = decodeInt64(decoded)
                            decoded = ival.buf
                            const booly = decodeBoolean(decoded)
                            decoded = booly.buf
                            return {
                                  buf: decoded,
                                  value: new OuterMiddleAAInner(ival.value,booly.value)
                                }
                        }
                    }

                    export class OuterMiddleBB {
                        constructor(inner: OuterMiddleBBInner) {
                            this._inner = inner
                        }

                        private _inner: OuterMiddleBBInner;

                        get inner(): OuterMiddleBBInner {
                            return this._inner
                        }

                        set inner(inner: OuterMiddleBBInner) {
                            this._inner = inner
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = this._inner.encode(encoded)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: OuterMiddleBB
                                } {
                            let decoded = buf
                            const inner = OuterMiddleBBInner.decode(decoded)
                            decoded = inner.buf
                            return {
                                  buf: decoded,
                                  value: new OuterMiddleBB(inner.value)
                                }
                        }
                    }

                    export class OuterMiddleBBInner {
                        constructor(ival: number, booly: boolean) {
                            this._ival = ival
                            this._booly = booly
                        }

                        private _ival: number;

                        get ival(): number {
                            return this._ival
                        }

                        set ival(ival: number) {
                            this._ival = ival
                        }

                        private _booly: boolean;

                        get booly(): boolean {
                            return this._booly
                        }

                        set booly(booly: boolean) {
                            this._booly = booly
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeInt32(encoded, this._ival)
                            encoded = encodeBoolean(encoded, this._booly)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: OuterMiddleBBInner
                                } {
                            let decoded = buf
                            const ival = decodeInt32(decoded)
                            decoded = ival.buf
                            const booly = decodeBoolean(decoded)
                            decoded = booly.buf
                            return {
                                  buf: decoded,
                                  value: new OuterMiddleBBInner(ival.value,booly.value)
                                }
                        }
                    }

                    export class SampleMessage {
                        constructor(name: string, potato: string) {
                            this._name = name
                            this._potato = potato
                        }

                        private _name: string;

                        get name(): string {
                            return this._name
                        }

                        set name(name: string) {
                            this._name = name
                        }

                        private _potato: string;

                        get potato(): string {
                            return this._potato
                        }

                        set potato(potato: string) {
                            this._potato = potato
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeString(encoded, this._name)
                            encoded = encodeString(encoded, this._potato)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: SampleMessage
                                } {
                            let decoded = buf
                            const name = decodeString(decoded)
                            decoded = name.buf
                            const potato = decodeString(decoded)
                            decoded = potato.buf
                            return {
                                  buf: decoded,
                                  value: new SampleMessage(name.value,potato.value)
                                }
                        }
                    }

                    export class TestPotato {
                        constructor(prices: Map<string, Test>) {
                            this._prices = prices
                        }

                        private _prices: Map<string, Test>;

                        get prices(): Map<string, Test> {
                            return this._prices
                        }

                        set prices(prices: Map<string, Test>) {
                            this._prices = prices
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeMap(encoded, this._prices.size,
                                          Kind.String, Kind.Any)
                            this._prices.forEach((value, key) => {
                                              encoded = encodeString(encoded, key);
                                              encoded = encodeUint8(encoded, value as number);
                                            })
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: TestPotato
                                } {
                            let decoded = buf
                            const pricesMap = decodeMap(decoded)
                            decoded = pricesMap.buf
                            const prices: { value: Map<string, Test> } = {
                                              value: new Map<string, Test>(),
                                            }

                            for (let i = 0; i < pricesMap.size; i++) {
                                              const key = decodeString(decoded);
                                              decoded = key.buf;
                                              const value = decodeUint8(decoded);
                                              decoded = value.buf;
                                              prices.value.set(key.value, value.value as Test);
                                            }

                            return {
                                  buf: decoded,
                                  value: new TestPotato(prices.value)
                                }
                        }
                    }

                    export class StockPrices {
                        constructor(prices: Map<string, number>) {
                            this._prices = prices
                        }

                        private _prices: Map<string, number>;

                        get prices(): Map<string, number> {
                            return this._prices
                        }

                        set prices(prices: Map<string, number>) {
                            this._prices = prices
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeMap(encoded, this._prices.size,
                                          Kind.String,
                                          Kind.Float64)
                            this._prices.forEach((value, key) => {
                                              encoded = encodeString(encoded, key);
                                              encoded = encodeFloat64(encoded, value);
                                            })
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: StockPrices
                                } {
                            let decoded = buf
                            const pricesMap = decodeMap(decoded)
                            decoded = pricesMap.buf
                            const prices: { value: Map<string, number> } = {
                                              value: new Map<string, number>(),
                                            }

                            for (let i = 0; i < pricesMap.size; i++) {
                                              const key = decodeString(decoded);
                                              decoded = key.buf;
                                              const value = decodeFloat64(decoded);
                                              decoded = value.buf;
                                              prices.value.set(key.value, value.value);
                                            }

                            return {
                                  buf: decoded,
                                  value: new StockPrices(prices.value)
                                }
                        }
                    }

                    export class StockPricesWrapper {
                        constructor(sPrices: StockPrices[]) {
                            this._sPrices = sPrices
                        }

                        private _sPrices: StockPrices[];

                        get sPrices(): StockPrices[] {
                            return this._sPrices
                        }

                        set sPrices(sPrices: StockPrices[]) {
                            this._sPrices = sPrices
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeArray(encoded, this._sPrices.length, Kind.Any)
                            this._sPrices.forEach((field) => {
                                              encoded = field.encode(encoded);
                                            })
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: StockPricesWrapper
                                } {
                            let decoded = buf
                            const sPricesArray = decodeArray(decoded)
                            decoded = sPricesArray.buf
                            const sPrices: { value: StockPrices[] } = {
                                              value: [],
                                            }

                            for (let i = 0; i < sPricesArray.size; i++) {
                                              const element = StockPrices.decode(decoded);
                                              decoded = element.buf;
                                              sPrices.value.push(element.value);
                                            }

                            return {
                                  buf: decoded,
                                  value: new StockPricesWrapper(sPrices.value)
                                }
                        }
                    }

                    export class StockPricesSuperWrap {
                        constructor(prices: Map<string, StockPricesWrapper>) {
                            this._prices = prices
                        }

                        private _prices: Map<string, StockPricesWrapper>;

                        get prices(): Map<string, StockPricesWrapper> {
                            return this._prices
                        }

                        set prices(prices: Map<string, StockPricesWrapper>) {
                            this._prices = prices
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeMap(encoded, this._prices.size,
                                          Kind.String, Kind.Any)
                            this._prices.forEach((value, key) => {
                                              encoded = encodeString(encoded, key);
                                              encoded = value.encode(encoded);
                                            })
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: StockPricesSuperWrap
                                } {
                            let decoded = buf
                            const pricesMap = decodeMap(decoded)
                            decoded = pricesMap.buf
                            const prices: { value: Map<string, StockPricesWrapper> } = {
                                              value: new Map<string, StockPricesWrapper>(),
                                            }

                            for (let i = 0; i < pricesMap.size; i++) {
                                              const key = decodeString(decoded);
                                              decoded = key.buf;
                                              const value = StockPricesWrapper.decode(decoded);
                                              decoded = value.buf;
                                              prices.value.set(key.value, value.value);
                                            }

                            return {
                                  buf: decoded,
                                  value: new StockPricesSuperWrap(prices.value)
                                }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for complex.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeFloat64, decodeFloat64, encodeFloat32, decodeFloat32, encodeInt64, decodeInt64, encodeInt32, decodeInt32, encodeUint32, decodeUint32, encodeUint64, decodeUint64, encodeBoolean, decodeBoolean, encodeString, decodeString, encodeUint8Array, decodeUint8Array } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace complex {
                        export class ExampleMessage {
                            constructor(a: number, b: number, d: bigint, g: number, c: number, e: number, f: bigint, i: number, j: bigint, m: boolean, k: number, l: bigint, h: bigint, n: string, o: Uint8Array) {
                                this._a = a
                                this._b = b
                                this._d = d
                                this._g = g
                                this._c = c
                                this._e = e
                                this._f = f
                                this._i = i
                                this._j = j
                                this._m = m
                                this._k = k
                                this._l = l
                                this._h = h
                                this._n = n
                                this._o = o
                            }

                            private _a: number;

                            get a(): number {
                                return this._a
                            }

                            set a(a: number) {
                                this._a = a
                            }

                            private _b: number;

                            get b(): number {
                                return this._b
                            }

                            set b(b: number) {
                                this._b = b
                            }

                            private _d: bigint;

                            get d(): bigint {
                                return this._d
                            }

                            set d(d: bigint) {
                                this._d = d
                            }

                            private _g: number;

                            get g(): number {
                                return this._g
                            }

                            set g(g: number) {
                                this._g = g
                            }

                            private _c: number;

                            get c(): number {
                                return this._c
                            }

                            set c(c: number) {
                                this._c = c
                            }

                            private _e: number;

                            get e(): number {
                                return this._e
                            }

                            set e(e: number) {
                                this._e = e
                            }

                            private _f: bigint;

                            get f(): bigint {
                                return this._f
                            }

                            set f(f: bigint) {
                                this._f = f
                            }

                            private _i: number;

                            get i(): number {
                                return this._i
                            }

                            set i(i: number) {
                                this._i = i
                            }

                            private _j: bigint;

                            get j(): bigint {
                                return this._j
                            }

                            set j(j: bigint) {
                                this._j = j
                            }

                            private _m: boolean;

                            get m(): boolean {
                                return this._m
                            }

                            set m(m: boolean) {
                                this._m = m
                            }

                            private _k: number;

                            get k(): number {
                                return this._k
                            }

                            set k(k: number) {
                                this._k = k
                            }

                            private _l: bigint;

                            get l(): bigint {
                                return this._l
                            }

                            set l(l: bigint) {
                                this._l = l
                            }

                            private _h: bigint;

                            get h(): bigint {
                                return this._h
                            }

                            set h(h: bigint) {
                                this._h = h
                            }

                            private _n: string;

                            get n(): string {
                                return this._n
                            }

                            set n(n: string) {
                                this._n = n
                            }

                            private _o: Uint8Array;

                            get o(): Uint8Array {
                                return this._o
                            }

                            set o(o: Uint8Array) {
                                this._o = o
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeFloat64(encoded, this._a)
                                encoded = encodeFloat32(encoded, this._b)
                                encoded = encodeInt64(encoded, this._d)
                                encoded = encodeInt32(encoded, this._g)
                                encoded = encodeInt32(encoded, this._c)
                                encoded = encodeUint32(encoded, this._e)
                                encoded = encodeUint64(encoded, this._f)
                                encoded = encodeUint32(encoded, this._i)
                                encoded = encodeUint64(encoded, this._j)
                                encoded = encodeBoolean(encoded, this._m)
                                encoded = encodeInt32(encoded, this._k)
                                encoded = encodeInt64(encoded, this._l)
                                encoded = encodeInt64(encoded, this._h)
                                encoded = encodeString(encoded, this._n)
                                encoded = encodeUint8Array(encoded, this._o)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: ExampleMessage
                                    } {
                                let decoded = buf
                                const a = decodeFloat64(decoded)
                                decoded = a.buf
                                const b = decodeFloat32(decoded)
                                decoded = b.buf
                                const d = decodeInt64(decoded)
                                decoded = d.buf
                                const g = decodeInt32(decoded)
                                decoded = g.buf
                                const c = decodeInt32(decoded)
                                decoded = c.buf
                                const e = decodeUint32(decoded)
                                decoded = e.buf
                                const f = decodeUint64(decoded)
                                decoded = f.buf
                                const i = decodeUint32(decoded)
                                decoded = i.buf
                                const j = decodeUint64(decoded)
                                decoded = j.buf
                                const m = decodeBoolean(decoded)
                                decoded = m.buf
                                const k = decodeInt32(decoded)
                                decoded = k.buf
                                const l = decodeInt64(decoded)
                                decoded = l.buf
                                const h = decodeInt64(decoded)
                                decoded = h.buf
                                const n = decodeString(decoded)
                                decoded = n.buf
                                const o = decodeUint8Array(decoded)
                                decoded = o.buf
                                return {
                                      buf: decoded,
                                      value: new ExampleMessage(a.value,b.value,d.value,g.value,c.value,e.value,f.value,i.value,j.value,m.value,k.value,l.value,h.value,n.value,o.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for edgecases.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeInt64, decodeInt64, encodeBoolean, decodeBoolean, encodeUint8Array, decodeUint8Array, encodeString, decodeString, encodeArray, Kind, encodeMap, decodeArray, decodeMap } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace edgecases {
                        export class ExampleMessage {
                            constructor(a: bigint[], b: boolean[], c: Uint8Array[], d: Map<string, bigint>, e: Map<string, boolean>, f: Map<string, string>, g: Map<string, Uint8Array>) {
                                this._a = a
                                this._b = b
                                this._c = c
                                this._d = d
                                this._e = e
                                this._f = f
                                this._g = g
                            }

                            private _a: bigint[];

                            get a(): bigint[] {
                                return this._a
                            }

                            set a(a: bigint[]) {
                                this._a = a
                            }

                            private _b: boolean[];

                            get b(): boolean[] {
                                return this._b
                            }

                            set b(b: boolean[]) {
                                this._b = b
                            }

                            private _c: Uint8Array[];

                            get c(): Uint8Array[] {
                                return this._c
                            }

                            set c(c: Uint8Array[]) {
                                this._c = c
                            }

                            private _d: Map<string, bigint>;

                            get d(): Map<string, bigint> {
                                return this._d
                            }

                            set d(d: Map<string, bigint>) {
                                this._d = d
                            }

                            private _e: Map<string, boolean>;

                            get e(): Map<string, boolean> {
                                return this._e
                            }

                            set e(e: Map<string, boolean>) {
                                this._e = e
                            }

                            private _f: Map<string, string>;

                            get f(): Map<string, string> {
                                return this._f
                            }

                            set f(f: Map<string, string>) {
                                this._f = f
                            }

                            private _g: Map<string, Uint8Array>;

                            get g(): Map<string, Uint8Array> {
                                return this._g
                            }

                            set g(g: Map<string, Uint8Array>) {
                                this._g = g
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeArray(encoded, this._a.length, Kind.Int64)
                                this._a.forEach(field => {
                                                  encoded = encodeInt64(encoded, field);
                                                })
                                encoded = encodeArray(encoded, this._b.length, Kind.Boolean)
                                this._b.forEach(field => {
                                                  encoded = encodeBoolean(encoded, field);
                                                })
                                encoded = encodeArray(encoded, this._c.length, Kind.Uint8Array)
                                this._c.forEach(field => {
                                                  encoded = encodeUint8Array(encoded, field);
                                                })
                                encoded = encodeMap(encoded, this._d.size,
                                              Kind.String,
                                              Kind.Int64)
                                this._d.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeInt64(encoded, value);
                                                })
                                encoded = encodeMap(encoded, this._e.size,
                                              Kind.String,
                                              Kind.Boolean)
                                this._e.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeBoolean(encoded, value);
                                                })
                                encoded = encodeMap(encoded, this._f.size,
                                              Kind.String,
                                              Kind.String)
                                this._f.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeString(encoded, value);
                                                })
                                encoded = encodeMap(encoded, this._g.size,
                                              Kind.String,
                                              Kind.Uint8Array)
                                this._g.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeUint8Array(encoded, value);
                                                })
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: ExampleMessage
                                    } {
                                let decoded = buf
                                const aArray = decodeArray(decoded)
                                decoded = aArray.buf
                                const a: { value: bigint[] } = {
                                                  value: [],
                                                }

                                for (let i = 0; i < aArray.size; i++) {
                                                  const element = decodeInt64(decoded);
                                                  decoded = element.buf;
                                                  a.value.push(element.value);
                                                }

                                const bArray = decodeArray(decoded)
                                decoded = bArray.buf
                                const b: { value: boolean[] } = {
                                                  value: [],
                                                }

                                for (let i = 0; i < bArray.size; i++) {
                                                  const element = decodeBoolean(decoded);
                                                  decoded = element.buf;
                                                  b.value.push(element.value);
                                                }

                                const cArray = decodeArray(decoded)
                                decoded = cArray.buf
                                const c: { value: Uint8Array[] } = {
                                                  value: [],
                                                }

                                for (let i = 0; i < cArray.size; i++) {
                                                  const element = decodeUint8Array(decoded);
                                                  decoded = element.buf;
                                                  c.value.push(element.value);
                                                }

                                const dMap = decodeMap(decoded)
                                decoded = dMap.buf
                                const d: { value: Map<string, bigint> } = {
                                                  value: new Map<string, bigint>(),
                                                }

                                for (let i = 0; i < dMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeInt64(decoded);
                                                  decoded = value.buf;
                                                  d.value.set(key.value, value.value);
                                                }

                                const eMap = decodeMap(decoded)
                                decoded = eMap.buf
                                const e: { value: Map<string, boolean> } = {
                                                  value: new Map<string, boolean>(),
                                                }

                                for (let i = 0; i < eMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeBoolean(decoded);
                                                  decoded = value.buf;
                                                  e.value.set(key.value, value.value);
                                                }

                                const fMap = decodeMap(decoded)
                                decoded = fMap.buf
                                const f: { value: Map<string, string> } = {
                                                  value: new Map<string, string>(),
                                                }

                                for (let i = 0; i < fMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeString(decoded);
                                                  decoded = value.buf;
                                                  f.value.set(key.value, value.value);
                                                }

                                const gMap = decodeMap(decoded)
                                decoded = gMap.buf
                                const g: { value: Map<string, Uint8Array> } = {
                                                  value: new Map<string, Uint8Array>(),
                                                }

                                for (let i = 0; i < gMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeUint8Array(decoded);
                                                  decoded = value.buf;
                                                  g.value.set(key.value, value.value);
                                                }

                                return {
                                      buf: decoded,
                                      value: new ExampleMessage(a.value,b.value,c.value,d.value,e.value,f.value,g.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for empty.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace empty {
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for empty_options.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace empty {
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for enum.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeUint8, decodeUint8 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace enm {
                        enum MessageType {
                            MESSAGE_TYPE_A = 0,
                            MESSAGE_TYPE_B = 1,
                            MESSAGE_TYPE_C = 2
                        }

                        export class ExampleMessage {
                            constructor(type: MessageType) {
                                this._type = type
                            }

                            private _type: MessageType;

                            get type(): MessageType {
                                return this._type
                            }

                            set type(type: MessageType) {
                                this._type = type
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeUint8(encoded, this._type as number)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: ExampleMessage
                                    } {
                                let decoded = buf
                                const typeUint8 = decodeUint8(decoded)
                                const type = { value: typeUint8.value as MessageType }

                                decoded = typeUint8.buf
                                return {
                                      buf: decoded,
                                      value: new ExampleMessage(type.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for http.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString, encodeUint64, decodeUint64, encodeUint8Array, decodeUint8Array, encodeUint32, decodeUint32, encodeMap, Kind, decodeMap } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace http {
                        export class Request {
                            constructor(method: string, url: string, length: bigint, origin: string, protocol: string, ip: string, body: Uint8Array, headers: Map<string, string>, query: Map<string, string>) {
                                this._method = method
                                this._url = url
                                this._length = length
                                this._origin = origin
                                this._protocol = protocol
                                this._ip = ip
                                this._body = body
                                this._headers = headers
                                this._query = query
                            }

                            private _method: string;

                            get method(): string {
                                return this._method
                            }

                            set method(method: string) {
                                this._method = method
                            }

                            private _url: string;

                            get url(): string {
                                return this._url
                            }

                            set url(url: string) {
                                this._url = url
                            }

                            private _length: bigint;

                            get length(): bigint {
                                return this._length
                            }

                            set length(length: bigint) {
                                this._length = length
                            }

                            private _origin: string;

                            get origin(): string {
                                return this._origin
                            }

                            set origin(origin: string) {
                                this._origin = origin
                            }

                            private _protocol: string;

                            get protocol(): string {
                                return this._protocol
                            }

                            set protocol(protocol: string) {
                                this._protocol = protocol
                            }

                            private _ip: string;

                            get ip(): string {
                                return this._ip
                            }

                            set ip(ip: string) {
                                this._ip = ip
                            }

                            private _body: Uint8Array;

                            get body(): Uint8Array {
                                return this._body
                            }

                            set body(body: Uint8Array) {
                                this._body = body
                            }

                            private _headers: Map<string, string>;

                            get headers(): Map<string, string> {
                                return this._headers
                            }

                            set headers(headers: Map<string, string>) {
                                this._headers = headers
                            }

                            private _query: Map<string, string>;

                            get query(): Map<string, string> {
                                return this._query
                            }

                            set query(query: Map<string, string>) {
                                this._query = query
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._method)
                                encoded = encodeString(encoded, this._url)
                                encoded = encodeUint64(encoded, this._length)
                                encoded = encodeString(encoded, this._origin)
                                encoded = encodeString(encoded, this._protocol)
                                encoded = encodeString(encoded, this._ip)
                                encoded = encodeUint8Array(encoded, this._body)
                                encoded = encodeMap(encoded, this._headers.size,
                                              Kind.String,
                                              Kind.String)
                                this._headers.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeString(encoded, value);
                                                })
                                encoded = encodeMap(encoded, this._query.size,
                                              Kind.String,
                                              Kind.String)
                                this._query.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeString(encoded, value);
                                                })
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: Request
                                    } {
                                let decoded = buf
                                const method = decodeString(decoded)
                                decoded = method.buf
                                const url = decodeString(decoded)
                                decoded = url.buf
                                const length = decodeUint64(decoded)
                                decoded = length.buf
                                const origin = decodeString(decoded)
                                decoded = origin.buf
                                const protocol = decodeString(decoded)
                                decoded = protocol.buf
                                const ip = decodeString(decoded)
                                decoded = ip.buf
                                const body = decodeUint8Array(decoded)
                                decoded = body.buf
                                const headersMap = decodeMap(decoded)
                                decoded = headersMap.buf
                                const headers: { value: Map<string, string> } = {
                                                  value: new Map<string, string>(),
                                                }

                                for (let i = 0; i < headersMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeString(decoded);
                                                  decoded = value.buf;
                                                  headers.value.set(key.value, value.value);
                                                }

                                const queryMap = decodeMap(decoded)
                                decoded = queryMap.buf
                                const query: { value: Map<string, string> } = {
                                                  value: new Map<string, string>(),
                                                }

                                for (let i = 0; i < queryMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeString(decoded);
                                                  decoded = value.buf;
                                                  query.value.set(key.value, value.value);
                                                }

                                return {
                                      buf: decoded,
                                      value: new Request(method.value,url.value,length.value,origin.value,protocol.value,ip.value,body.value,headers.value,query.value)
                                    }
                            }
                        }

                        export class Response {
                            constructor(status: number, body: Uint8Array, headers: Map<string, string>) {
                                this._status = status
                                this._body = body
                                this._headers = headers
                            }

                            private _status: number;

                            get status(): number {
                                return this._status
                            }

                            set status(status: number) {
                                this._status = status
                            }

                            private _body: Uint8Array;

                            get body(): Uint8Array {
                                return this._body
                            }

                            set body(body: Uint8Array) {
                                this._body = body
                            }

                            private _headers: Map<string, string>;

                            get headers(): Map<string, string> {
                                return this._headers
                            }

                            set headers(headers: Map<string, string>) {
                                this._headers = headers
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeUint32(encoded, this._status)
                                encoded = encodeUint8Array(encoded, this._body)
                                encoded = encodeMap(encoded, this._headers.size,
                                              Kind.String,
                                              Kind.String)
                                this._headers.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeString(encoded, value);
                                                })
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: Response
                                    } {
                                let decoded = buf
                                const status = decodeUint32(decoded)
                                decoded = status.buf
                                const body = decodeUint8Array(decoded)
                                decoded = body.buf
                                const headersMap = decodeMap(decoded)
                                decoded = headersMap.buf
                                const headers: { value: Map<string, string> } = {
                                                  value: new Map<string, string>(),
                                                }

                                for (let i = 0; i < headersMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeString(decoded);
                                                  decoded = value.buf;
                                                  headers.value.set(key.value, value.value);
                                                }

                                return {
                                      buf: decoded,
                                      value: new Response(status.value,body.value,headers.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for map.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt32, decodeInt32, encodeFloat64, decodeFloat64, encodeMap, Kind, decodeMap } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace map {
                        export class ExampleMessage {
                            constructor(name: string, balances: Map<string, number>, backlinks: Map<string, number>) {
                                this._name = name
                                this._balances = balances
                                this._backlinks = backlinks
                            }

                            private _name: string;

                            get name(): string {
                                return this._name
                            }

                            set name(name: string) {
                                this._name = name
                            }

                            private _balances: Map<string, number>;

                            get balances(): Map<string, number> {
                                return this._balances
                            }

                            set balances(balances: Map<string, number>) {
                                this._balances = balances
                            }

                            private _backlinks: Map<string, number>;

                            get backlinks(): Map<string, number> {
                                return this._backlinks
                            }

                            set backlinks(backlinks: Map<string, number>) {
                                this._backlinks = backlinks
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._name)
                                encoded = encodeMap(encoded, this._balances.size,
                                              Kind.String,
                                              Kind.Int32)
                                this._balances.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeInt32(encoded, value);
                                                })
                                encoded = encodeMap(encoded, this._backlinks.size,
                                              Kind.String,
                                              Kind.Float64)
                                this._backlinks.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeFloat64(encoded, value);
                                                })
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: ExampleMessage
                                    } {
                                let decoded = buf
                                const name = decodeString(decoded)
                                decoded = name.buf
                                const balancesMap = decodeMap(decoded)
                                decoded = balancesMap.buf
                                const balances: { value: Map<string, number> } = {
                                                  value: new Map<string, number>(),
                                                }

                                for (let i = 0; i < balancesMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeInt32(decoded);
                                                  decoded = value.buf;
                                                  balances.value.set(key.value, value.value);
                                                }

                                const backlinksMap = decodeMap(decoded)
                                decoded = backlinksMap.buf
                                const backlinks: { value: Map<string, number> } = {
                                                  value: new Map<string, number>(),
                                                }

                                for (let i = 0; i < backlinksMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeFloat64(decoded);
                                                  decoded = value.buf;
                                                  backlinks.value.set(key.value, value.value);
                                                }

                                return {
                                      buf: decoded,
                                      value: new ExampleMessage(name.value,balances.value,backlinks.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for map_composite.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt32, decodeInt32, encodeMap, Kind, decodeMap } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace map {
                        export namespace composite {
                            export class ExampleMessage {
                                constructor(name: string, balances: Map<string, number>, backlinks: Map<string, NestedExampleMessage>) {
                                    this._name = name
                                    this._balances = balances
                                    this._backlinks = backlinks
                                }

                                private _name: string;

                                get name(): string {
                                    return this._name
                                }

                                set name(name: string) {
                                    this._name = name
                                }

                                private _balances: Map<string, number>;

                                get balances(): Map<string, number> {
                                    return this._balances
                                }

                                set balances(balances: Map<string, number>) {
                                    this._balances = balances
                                }

                                private _backlinks: Map<string, NestedExampleMessage>;

                                get backlinks(): Map<string, NestedExampleMessage> {
                                    return this._backlinks
                                }

                                set backlinks(backlinks: Map<string, NestedExampleMessage>) {
                                    this._backlinks = backlinks
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeString(encoded, this._name)
                                    encoded = encodeMap(encoded, this._balances.size,
                                                  Kind.String,
                                                  Kind.Int32)
                                    this._balances.forEach((value, key) => {
                                                      encoded = encodeString(encoded, key);
                                                      encoded = encodeInt32(encoded, value);
                                                    })
                                    encoded = encodeMap(encoded, this._backlinks.size,
                                                  Kind.String, Kind.Any)
                                    this._backlinks.forEach((value, key) => {
                                                      encoded = encodeString(encoded, key);
                                                      encoded = value.encode(encoded);
                                                    })
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: ExampleMessage
                                        } {
                                    let decoded = buf
                                    const name = decodeString(decoded)
                                    decoded = name.buf
                                    const balancesMap = decodeMap(decoded)
                                    decoded = balancesMap.buf
                                    const balances: { value: Map<string, number> } = {
                                                      value: new Map<string, number>(),
                                                    }

                                    for (let i = 0; i < balancesMap.size; i++) {
                                                      const key = decodeString(decoded);
                                                      decoded = key.buf;
                                                      const value = decodeInt32(decoded);
                                                      decoded = value.buf;
                                                      balances.value.set(key.value, value.value);
                                                    }

                                    const backlinksMap = decodeMap(decoded)
                                    decoded = backlinksMap.buf
                                    const backlinks: { value: Map<string, NestedExampleMessage> } = {
                                                      value: new Map<string, NestedExampleMessage>(),
                                                    }

                                    for (let i = 0; i < backlinksMap.size; i++) {
                                                      const key = decodeString(decoded);
                                                      decoded = key.buf;
                                                      const value = NestedExampleMessage.decode(decoded);
                                                      decoded = value.buf;
                                                      backlinks.value.set(key.value, value.value);
                                                    }

                                    return {
                                          buf: decoded,
                                          value: new ExampleMessage(name.value,balances.value,backlinks.value)
                                        }
                                }
                            }

                            export class NestedExampleMessage {
                                constructor(age: number) {
                                    this._age = age
                                }

                                private _age: number;

                                get age(): number {
                                    return this._age
                                }

                                set age(age: number) {
                                    this._age = age
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeInt32(encoded, this._age)
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: NestedExampleMessage
                                        } {
                                    let decoded = buf
                                    const age = decodeInt32(decoded)
                                    decoded = age.buf
                                    return {
                                          buf: decoded,
                                          value: new NestedExampleMessage(age.value)
                                        }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for map_enum.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt32, decodeInt32, encodeMap, Kind, encodeUint8, decodeMap, decodeUint8 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace map {
                        export namespace enm {
                            enum MessageType {
                                MESSAGE_TYPE_A = 0,
                                MESSAGE_TYPE_B = 1,
                                MESSAGE_TYPE_C = 2
                            }

                            export class ExampleMessage {
                                constructor(name: string, balances: Map<string, number>, backlinks: Map<string, MessageType>) {
                                    this._name = name
                                    this._balances = balances
                                    this._backlinks = backlinks
                                }

                                private _name: string;

                                get name(): string {
                                    return this._name
                                }

                                set name(name: string) {
                                    this._name = name
                                }

                                private _balances: Map<string, number>;

                                get balances(): Map<string, number> {
                                    return this._balances
                                }

                                set balances(balances: Map<string, number>) {
                                    this._balances = balances
                                }

                                private _backlinks: Map<string, MessageType>;

                                get backlinks(): Map<string, MessageType> {
                                    return this._backlinks
                                }

                                set backlinks(backlinks: Map<string, MessageType>) {
                                    this._backlinks = backlinks
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeString(encoded, this._name)
                                    encoded = encodeMap(encoded, this._balances.size,
                                                  Kind.String,
                                                  Kind.Int32)
                                    this._balances.forEach((value, key) => {
                                                      encoded = encodeString(encoded, key);
                                                      encoded = encodeInt32(encoded, value);
                                                    })
                                    encoded = encodeMap(encoded, this._backlinks.size,
                                                  Kind.String, Kind.Any)
                                    this._backlinks.forEach((value, key) => {
                                                      encoded = encodeString(encoded, key);
                                                      encoded = encodeUint8(encoded, value as number);
                                                    })
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: ExampleMessage
                                        } {
                                    let decoded = buf
                                    const name = decodeString(decoded)
                                    decoded = name.buf
                                    const balancesMap = decodeMap(decoded)
                                    decoded = balancesMap.buf
                                    const balances: { value: Map<string, number> } = {
                                                      value: new Map<string, number>(),
                                                    }

                                    for (let i = 0; i < balancesMap.size; i++) {
                                                      const key = decodeString(decoded);
                                                      decoded = key.buf;
                                                      const value = decodeInt32(decoded);
                                                      decoded = value.buf;
                                                      balances.value.set(key.value, value.value);
                                                    }

                                    const backlinksMap = decodeMap(decoded)
                                    decoded = backlinksMap.buf
                                    const backlinks: { value: Map<string, MessageType> } = {
                                                      value: new Map<string, MessageType>(),
                                                    }

                                    for (let i = 0; i < backlinksMap.size; i++) {
                                                      const key = decodeString(decoded);
                                                      decoded = key.buf;
                                                      const value = decodeUint8(decoded);
                                                      decoded = value.buf;
                                                      backlinks.value.set(key.value, value.value as MessageType);
                                                    }

                                    return {
                                          buf: decoded,
                                          value: new ExampleMessage(name.value,balances.value,backlinks.value)
                                        }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeInt64, decodeInt64, encodeBoolean, decodeBoolean, encodeInt32, decodeInt32 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export class Outer {
                        constructor(a: OuterMiddleAA, b: OuterMiddleBB) {
                            this._a = a
                            this._b = b
                        }

                        private _a: OuterMiddleAA;

                        get a(): OuterMiddleAA {
                            return this._a
                        }

                        set a(a: OuterMiddleAA) {
                            this._a = a
                        }

                        private _b: OuterMiddleBB;

                        get b(): OuterMiddleBB {
                            return this._b
                        }

                        set b(b: OuterMiddleBB) {
                            this._b = b
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = this._a.encode(encoded)
                            encoded = this._b.encode(encoded)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: Outer
                                } {
                            let decoded = buf
                            const a = OuterMiddleAA.decode(decoded)
                            decoded = a.buf
                            const b = OuterMiddleBB.decode(decoded)
                            decoded = b.buf
                            return {
                                  buf: decoded,
                                  value: new Outer(a.value,b.value)
                                }
                        }
                    }

                    export class OuterMiddleAA {
                        constructor(a: OuterMiddleAAInner) {
                            this._a = a
                        }

                        private _a: OuterMiddleAAInner;

                        get a(): OuterMiddleAAInner {
                            return this._a
                        }

                        set a(a: OuterMiddleAAInner) {
                            this._a = a
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = this._a.encode(encoded)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: OuterMiddleAA
                                } {
                            let decoded = buf
                            const a = OuterMiddleAAInner.decode(decoded)
                            decoded = a.buf
                            return {
                                  buf: decoded,
                                  value: new OuterMiddleAA(a.value)
                                }
                        }
                    }

                    export class OuterMiddleAAInner {
                        constructor(a: bigint, b: boolean) {
                            this._a = a
                            this._b = b
                        }

                        private _a: bigint;

                        get a(): bigint {
                            return this._a
                        }

                        set a(a: bigint) {
                            this._a = a
                        }

                        private _b: boolean;

                        get b(): boolean {
                            return this._b
                        }

                        set b(b: boolean) {
                            this._b = b
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeInt64(encoded, this._a)
                            encoded = encodeBoolean(encoded, this._b)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: OuterMiddleAAInner
                                } {
                            let decoded = buf
                            const a = decodeInt64(decoded)
                            decoded = a.buf
                            const b = decodeBoolean(decoded)
                            decoded = b.buf
                            return {
                                  buf: decoded,
                                  value: new OuterMiddleAAInner(a.value,b.value)
                                }
                        }
                    }

                    export class OuterMiddleBB {
                        constructor(a: OuterMiddleBBInner) {
                            this._a = a
                        }

                        private _a: OuterMiddleBBInner;

                        get a(): OuterMiddleBBInner {
                            return this._a
                        }

                        set a(a: OuterMiddleBBInner) {
                            this._a = a
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = this._a.encode(encoded)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: OuterMiddleBB
                                } {
                            let decoded = buf
                            const a = OuterMiddleBBInner.decode(decoded)
                            decoded = a.buf
                            return {
                                  buf: decoded,
                                  value: new OuterMiddleBB(a.value)
                                }
                        }
                    }

                    export class OuterMiddleBBInner {
                        constructor(a: number, b: boolean) {
                            this._a = a
                            this._b = b
                        }

                        private _a: number;

                        get a(): number {
                            return this._a
                        }

                        set a(a: number) {
                            this._a = a
                        }

                        private _b: boolean;

                        get b(): boolean {
                            return this._b
                        }

                        set b(b: boolean) {
                            this._b = b
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeInt32(encoded, this._a)
                            encoded = encodeBoolean(encoded, this._b)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: OuterMiddleBBInner
                                } {
                            let decoded = buf
                            const a = decodeInt32(decoded)
                            decoded = a.buf
                            const b = decodeBoolean(decoded)
                            decoded = b.buf
                            return {
                                  buf: decoded,
                                  value: new OuterMiddleBBInner(a.value,b.value)
                                }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_array.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeInt64, decodeInt64, encodeBoolean, decodeBoolean, encodeInt32, decodeInt32, encodeArray, Kind, decodeArray } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace array {
                        export class Outer {
                            constructor(b: OuterMiddleBB[], a: OuterMiddleAA) {
                                this._b = b
                                this._a = a
                            }

                            private _b: OuterMiddleBB[];

                            get b(): OuterMiddleBB[] {
                                return this._b
                            }

                            set b(b: OuterMiddleBB[]) {
                                this._b = b
                            }

                            private _a: OuterMiddleAA;

                            get a(): OuterMiddleAA {
                                return this._a
                            }

                            set a(a: OuterMiddleAA) {
                                this._a = a
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeArray(encoded, this._b.length, Kind.Any)
                                this._b.forEach((field) => {
                                                  encoded = field.encode(encoded);
                                                })
                                encoded = this._a.encode(encoded)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: Outer
                                    } {
                                let decoded = buf
                                const bArray = decodeArray(decoded)
                                decoded = bArray.buf
                                const b: { value: OuterMiddleBB[] } = {
                                                  value: [],
                                                }

                                for (let i = 0; i < bArray.size; i++) {
                                                  const element = OuterMiddleBB.decode(decoded);
                                                  decoded = element.buf;
                                                  b.value.push(element.value);
                                                }

                                const a = OuterMiddleAA.decode(decoded)
                                decoded = a.buf
                                return {
                                      buf: decoded,
                                      value: new Outer(b.value,a.value)
                                    }
                            }
                        }

                        export class OuterMiddleAA {
                            constructor(a: OuterMiddleAAInner[]) {
                                this._a = a
                            }

                            private _a: OuterMiddleAAInner[];

                            get a(): OuterMiddleAAInner[] {
                                return this._a
                            }

                            set a(a: OuterMiddleAAInner[]) {
                                this._a = a
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeArray(encoded, this._a.length, Kind.Any)
                                this._a.forEach((field) => {
                                                  encoded = field.encode(encoded);
                                                })
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleAA
                                    } {
                                let decoded = buf
                                const aArray = decodeArray(decoded)
                                decoded = aArray.buf
                                const a: { value: OuterMiddleAAInner[] } = {
                                                  value: [],
                                                }

                                for (let i = 0; i < aArray.size; i++) {
                                                  const element = OuterMiddleAAInner.decode(decoded);
                                                  decoded = element.buf;
                                                  a.value.push(element.value);
                                                }

                                return {
                                      buf: decoded,
                                      value: new OuterMiddleAA(a.value)
                                    }
                            }
                        }

                        export class OuterMiddleAAInner {
                            constructor(a: bigint, b: boolean) {
                                this._a = a
                                this._b = b
                            }

                            private _a: bigint;

                            get a(): bigint {
                                return this._a
                            }

                            set a(a: bigint) {
                                this._a = a
                            }

                            private _b: boolean;

                            get b(): boolean {
                                return this._b
                            }

                            set b(b: boolean) {
                                this._b = b
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeInt64(encoded, this._a)
                                encoded = encodeBoolean(encoded, this._b)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleAAInner
                                    } {
                                let decoded = buf
                                const a = decodeInt64(decoded)
                                decoded = a.buf
                                const b = decodeBoolean(decoded)
                                decoded = b.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleAAInner(a.value,b.value)
                                    }
                            }
                        }

                        export class OuterMiddleBB {
                            constructor(a: OuterMiddleBBInner) {
                                this._a = a
                            }

                            private _a: OuterMiddleBBInner;

                            get a(): OuterMiddleBBInner {
                                return this._a
                            }

                            set a(a: OuterMiddleBBInner) {
                                this._a = a
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = this._a.encode(encoded)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleBB
                                    } {
                                let decoded = buf
                                const a = OuterMiddleBBInner.decode(decoded)
                                decoded = a.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleBB(a.value)
                                    }
                            }
                        }

                        export class OuterMiddleBBInner {
                            constructor(a: number, b: boolean) {
                                this._a = a
                                this._b = b
                            }

                            private _a: number;

                            get a(): number {
                                return this._a
                            }

                            set a(a: number) {
                                this._a = a
                            }

                            private _b: boolean;

                            get b(): boolean {
                                return this._b
                            }

                            set b(b: boolean) {
                                this._b = b
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeInt32(encoded, this._a)
                                encoded = encodeBoolean(encoded, this._b)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleBBInner
                                    } {
                                let decoded = buf
                                const a = decodeInt32(decoded)
                                decoded = a.buf
                                const b = decodeBoolean(decoded)
                                decoded = b.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleBBInner(a.value,b.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_enum.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString, encodeUint8, decodeUint8 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace enm {
                        enum RequestCorpus {
                            UNIVERSAL = 0,
                            WEB = 1,
                            IMAGES = 2,
                            LOCAL = 3,
                            NEWS = 4,
                            PRODUCTS = 5,
                            VIDEO = 6
                        }

                        export class Request {
                            constructor(Message: string, corpus: RequestCorpus) {
                                this._Message = Message
                                this._corpus = corpus
                            }

                            private _Message: string;

                            get Message(): string {
                                return this._Message
                            }

                            set Message(Message: string) {
                                this._Message = Message
                            }

                            private _corpus: RequestCorpus;

                            get corpus(): RequestCorpus {
                                return this._corpus
                            }

                            set corpus(corpus: RequestCorpus) {
                                this._corpus = corpus
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._Message)
                                encoded = encodeUint8(encoded, this._corpus as number)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: Request
                                    } {
                                let decoded = buf
                                const Message = decodeString(decoded)
                                decoded = Message.buf
                                const corpusUint8 = decodeUint8(decoded)
                                const corpus = { value: corpusUint8.value as RequestCorpus }

                                decoded = corpusUint8.buf
                                return {
                                      buf: decoded,
                                      value: new Request(Message.value,corpus.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_enum_array.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString, encodeUint8, encodeArray, Kind, decodeUint8, decodeArray } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace enm {
                        export namespace array {
                            enum RequestCorpus {
                                UNIVERSAL = 0,
                                WEB = 1,
                                IMAGES = 2,
                                LOCAL = 3,
                                NEWS = 4,
                                PRODUCTS = 5,
                                VIDEO = 6
                            }

                            export class Request {
                                constructor(Message: string, corpus: RequestCorpus[]) {
                                    this._Message = Message
                                    this._corpus = corpus
                                }

                                private _Message: string;

                                get Message(): string {
                                    return this._Message
                                }

                                set Message(Message: string) {
                                    this._Message = Message
                                }

                                private _corpus: RequestCorpus[];

                                get corpus(): RequestCorpus[] {
                                    return this._corpus
                                }

                                set corpus(corpus: RequestCorpus[]) {
                                    this._corpus = corpus
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeString(encoded, this._Message)
                                    encoded = encodeArray(encoded, this._corpus.length, Kind.Any)
                                    this._corpus.forEach(field => {
                                                      encoded = encodeUint8(encoded, field as number);
                                                    })
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: Request
                                        } {
                                    let decoded = buf
                                    const Message = decodeString(decoded)
                                    decoded = Message.buf
                                    const corpusArray = decodeArray(decoded)
                                    decoded = corpusArray.buf
                                    const corpus: { value: RequestCorpus[] } = {
                                                      value: [],
                                                    }

                                    for (let i = 0; i < corpusArray.size; i++) {
                                                      const element = decodeUint8(decoded);
                                                      decoded = element.buf;
                                                      corpus.value.push(element.value as RequestCorpus);
                                                    }

                                    return {
                                          buf: decoded,
                                          value: new Request(Message.value,corpus.value)
                                        }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_enum_deeper.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString, encodeUint8, decodeUint8 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace enm {
                        enum RequestNestedRequestCorpus {
                            UNIVERSAL = 0,
                            WEB = 1,
                            IMAGES = 2,
                            LOCAL = 3,
                            NEWS = 4,
                            PRODUCTS = 5,
                            VIDEO = 6
                        }

                        export class Request {
                            constructor(Message: string, corpus: RequestNestedRequestCorpus) {
                                this._Message = Message
                                this._corpus = corpus
                            }

                            private _Message: string;

                            get Message(): string {
                                return this._Message
                            }

                            set Message(Message: string) {
                                this._Message = Message
                            }

                            private _corpus: RequestNestedRequestCorpus;

                            get corpus(): RequestNestedRequestCorpus {
                                return this._corpus
                            }

                            set corpus(corpus: RequestNestedRequestCorpus) {
                                this._corpus = corpus
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._Message)
                                encoded = encodeUint8(encoded, this._corpus as number)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: Request
                                    } {
                                let decoded = buf
                                const Message = decodeString(decoded)
                                decoded = Message.buf
                                const corpusUint8 = decodeUint8(decoded)
                                const corpus = { value: corpusUint8.value as RequestNestedRequestCorpus }

                                decoded = corpusUint8.buf
                                return {
                                      buf: decoded,
                                      value: new Request(Message.value,corpus.value)
                                    }
                            }
                        }

                        export class RequestNestedRequest {
                            constructor() {
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: RequestNestedRequest
                                    } {
                                let decoded = buf
                                return {
                                      buf: decoded,
                                      value: new RequestNestedRequest()
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_enum_map.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString, encodeUint8, encodeMap, Kind, decodeUint8, decodeMap } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace enm {
                        export namespace map {
                            enum RequestCorpus {
                                UNIVERSAL = 0,
                                WEB = 1,
                                IMAGES = 2,
                                LOCAL = 3,
                                NEWS = 4,
                                PRODUCTS = 5,
                                VIDEO = 6
                            }

                            export class Request {
                                constructor(Message: string, corpus: Map<string, RequestCorpus>) {
                                    this._Message = Message
                                    this._corpus = corpus
                                }

                                private _Message: string;

                                get Message(): string {
                                    return this._Message
                                }

                                set Message(Message: string) {
                                    this._Message = Message
                                }

                                private _corpus: Map<string, RequestCorpus>;

                                get corpus(): Map<string, RequestCorpus> {
                                    return this._corpus
                                }

                                set corpus(corpus: Map<string, RequestCorpus>) {
                                    this._corpus = corpus
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeString(encoded, this._Message)
                                    encoded = encodeMap(encoded, this._corpus.size,
                                                  Kind.String, Kind.Any)
                                    this._corpus.forEach((value, key) => {
                                                      encoded = encodeString(encoded, key);
                                                      encoded = encodeUint8(encoded, value as number);
                                                    })
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: Request
                                        } {
                                    let decoded = buf
                                    const Message = decodeString(decoded)
                                    decoded = Message.buf
                                    const corpusMap = decodeMap(decoded)
                                    decoded = corpusMap.buf
                                    const corpus: { value: Map<string, RequestCorpus> } = {
                                                      value: new Map<string, RequestCorpus>(),
                                                    }

                                    for (let i = 0; i < corpusMap.size; i++) {
                                                      const key = decodeString(decoded);
                                                      decoded = key.buf;
                                                      const value = decodeUint8(decoded);
                                                      decoded = value.buf;
                                                      corpus.value.set(key.value, value.value as RequestCorpus);
                                                    }

                                    return {
                                          buf: decoded,
                                          value: new Request(Message.value,corpus.value)
                                        }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_enum_reference.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeInt64, decodeInt64, encodeBoolean, decodeBoolean, encodeInt32, decodeInt32, encodeUint8, decodeUint8 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace enm {
                        export namespace reference {
                            enum OuterMiddleBBCorpus {
                                UNIVERSAL = 0,
                                WEB = 1,
                                IMAGES = 2,
                                LOCAL = 3,
                                NEWS = 4,
                                PRODUCTS = 5,
                                VIDEO = 6
                            }

                            export class Outer {
                                constructor(c: OuterMiddleBBCorpus, a: OuterMiddleAA, b: OuterMiddleBBInner) {
                                    this._c = c
                                    this._a = a
                                    this._b = b
                                }

                                private _c: OuterMiddleBBCorpus;

                                get c(): OuterMiddleBBCorpus {
                                    return this._c
                                }

                                set c(c: OuterMiddleBBCorpus) {
                                    this._c = c
                                }

                                private _a: OuterMiddleAA;

                                get a(): OuterMiddleAA {
                                    return this._a
                                }

                                set a(a: OuterMiddleAA) {
                                    this._a = a
                                }

                                private _b: OuterMiddleBBInner;

                                get b(): OuterMiddleBBInner {
                                    return this._b
                                }

                                set b(b: OuterMiddleBBInner) {
                                    this._b = b
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeUint8(encoded, this._c as number)
                                    encoded = this._a.encode(encoded)
                                    encoded = this._b.encode(encoded)
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: Outer
                                        } {
                                    let decoded = buf
                                    const cUint8 = decodeUint8(decoded)
                                    const c = { value: cUint8.value as OuterMiddleBBCorpus }

                                    decoded = cUint8.buf
                                    const a = OuterMiddleAA.decode(decoded)
                                    decoded = a.buf
                                    const b = OuterMiddleBBInner.decode(decoded)
                                    decoded = b.buf
                                    return {
                                          buf: decoded,
                                          value: new Outer(c.value,a.value,b.value)
                                        }
                                }
                            }

                            export class OuterMiddleAA {
                                constructor(a: OuterMiddleAAInner) {
                                    this._a = a
                                }

                                private _a: OuterMiddleAAInner;

                                get a(): OuterMiddleAAInner {
                                    return this._a
                                }

                                set a(a: OuterMiddleAAInner) {
                                    this._a = a
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = this._a.encode(encoded)
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: OuterMiddleAA
                                        } {
                                    let decoded = buf
                                    const a = OuterMiddleAAInner.decode(decoded)
                                    decoded = a.buf
                                    return {
                                          buf: decoded,
                                          value: new OuterMiddleAA(a.value)
                                        }
                                }
                            }

                            export class OuterMiddleAAInner {
                                constructor(a: bigint, b: boolean) {
                                    this._a = a
                                    this._b = b
                                }

                                private _a: bigint;

                                get a(): bigint {
                                    return this._a
                                }

                                set a(a: bigint) {
                                    this._a = a
                                }

                                private _b: boolean;

                                get b(): boolean {
                                    return this._b
                                }

                                set b(b: boolean) {
                                    this._b = b
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeInt64(encoded, this._a)
                                    encoded = encodeBoolean(encoded, this._b)
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: OuterMiddleAAInner
                                        } {
                                    let decoded = buf
                                    const a = decodeInt64(decoded)
                                    decoded = a.buf
                                    const b = decodeBoolean(decoded)
                                    decoded = b.buf
                                    return {
                                          buf: decoded,
                                          value: new OuterMiddleAAInner(a.value,b.value)
                                        }
                                }
                            }

                            export class OuterMiddleBB {
                                constructor(a: OuterMiddleBBInner) {
                                    this._a = a
                                }

                                private _a: OuterMiddleBBInner;

                                get a(): OuterMiddleBBInner {
                                    return this._a
                                }

                                set a(a: OuterMiddleBBInner) {
                                    this._a = a
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = this._a.encode(encoded)
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: OuterMiddleBB
                                        } {
                                    let decoded = buf
                                    const a = OuterMiddleBBInner.decode(decoded)
                                    decoded = a.buf
                                    return {
                                          buf: decoded,
                                          value: new OuterMiddleBB(a.value)
                                        }
                                }
                            }

                            export class OuterMiddleBBInner {
                                constructor(a: number, b: boolean) {
                                    this._a = a
                                    this._b = b
                                }

                                private _a: number;

                                get a(): number {
                                    return this._a
                                }

                                set a(a: number) {
                                    this._a = a
                                }

                                private _b: boolean;

                                get b(): boolean {
                                    return this._b
                                }

                                set b(b: boolean) {
                                    this._b = b
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeInt32(encoded, this._a)
                                    encoded = encodeBoolean(encoded, this._b)
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: OuterMiddleBBInner
                                        } {
                                    let decoded = buf
                                    const a = decodeInt32(decoded)
                                    decoded = a.buf
                                    const b = decodeBoolean(decoded)
                                    decoded = b.buf
                                    return {
                                          buf: decoded,
                                          value: new OuterMiddleBBInner(a.value,b.value)
                                        }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_map.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt64, decodeInt64, encodeBoolean, decodeBoolean, encodeInt32, decodeInt32, encodeMap, Kind, decodeMap } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace array {
                        export class Outer {
                            constructor(a: OuterMiddleAA, b: Map<string, OuterMiddleBB>) {
                                this._a = a
                                this._b = b
                            }

                            private _a: OuterMiddleAA;

                            get a(): OuterMiddleAA {
                                return this._a
                            }

                            set a(a: OuterMiddleAA) {
                                this._a = a
                            }

                            private _b: Map<string, OuterMiddleBB>;

                            get b(): Map<string, OuterMiddleBB> {
                                return this._b
                            }

                            set b(b: Map<string, OuterMiddleBB>) {
                                this._b = b
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = this._a.encode(encoded)
                                encoded = encodeMap(encoded, this._b.size,
                                              Kind.String, Kind.Any)
                                this._b.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = value.encode(encoded);
                                                })
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: Outer
                                    } {
                                let decoded = buf
                                const a = OuterMiddleAA.decode(decoded)
                                decoded = a.buf
                                const bMap = decodeMap(decoded)
                                decoded = bMap.buf
                                const b: { value: Map<string, OuterMiddleBB> } = {
                                                  value: new Map<string, OuterMiddleBB>(),
                                                }

                                for (let i = 0; i < bMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = OuterMiddleBB.decode(decoded);
                                                  decoded = value.buf;
                                                  b.value.set(key.value, value.value);
                                                }

                                return {
                                      buf: decoded,
                                      value: new Outer(a.value,b.value)
                                    }
                            }
                        }

                        export class OuterMiddleAA {
                            constructor(a: OuterMiddleAAInner) {
                                this._a = a
                            }

                            private _a: OuterMiddleAAInner;

                            get a(): OuterMiddleAAInner {
                                return this._a
                            }

                            set a(a: OuterMiddleAAInner) {
                                this._a = a
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = this._a.encode(encoded)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleAA
                                    } {
                                let decoded = buf
                                const a = OuterMiddleAAInner.decode(decoded)
                                decoded = a.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleAA(a.value)
                                    }
                            }
                        }

                        export class OuterMiddleAAInner {
                            constructor(a: bigint, b: boolean) {
                                this._a = a
                                this._b = b
                            }

                            private _a: bigint;

                            get a(): bigint {
                                return this._a
                            }

                            set a(a: bigint) {
                                this._a = a
                            }

                            private _b: boolean;

                            get b(): boolean {
                                return this._b
                            }

                            set b(b: boolean) {
                                this._b = b
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeInt64(encoded, this._a)
                                encoded = encodeBoolean(encoded, this._b)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleAAInner
                                    } {
                                let decoded = buf
                                const a = decodeInt64(decoded)
                                decoded = a.buf
                                const b = decodeBoolean(decoded)
                                decoded = b.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleAAInner(a.value,b.value)
                                    }
                            }
                        }

                        export class OuterMiddleBB {
                            constructor(a: OuterMiddleBBInner) {
                                this._a = a
                            }

                            private _a: OuterMiddleBBInner;

                            get a(): OuterMiddleBBInner {
                                return this._a
                            }

                            set a(a: OuterMiddleBBInner) {
                                this._a = a
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = this._a.encode(encoded)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleBB
                                    } {
                                let decoded = buf
                                const a = OuterMiddleBBInner.decode(decoded)
                                decoded = a.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleBB(a.value)
                                    }
                            }
                        }

                        export class OuterMiddleBBInner {
                            constructor(a: number, b: boolean) {
                                this._a = a
                                this._b = b
                            }

                            private _a: number;

                            get a(): number {
                                return this._a
                            }

                            set a(a: number) {
                                this._a = a
                            }

                            private _b: boolean;

                            get b(): boolean {
                                return this._b
                            }

                            set b(b: boolean) {
                                this._b = b
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeInt32(encoded, this._a)
                                encoded = encodeBoolean(encoded, this._b)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleBBInner
                                    } {
                                let decoded = buf
                                const a = decodeInt32(decoded)
                                decoded = a.buf
                                const b = decodeBoolean(decoded)
                                decoded = b.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleBBInner(a.value,b.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_reference.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeInt64, decodeInt64, encodeBoolean, decodeBoolean, encodeInt32, decodeInt32 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace reference {
                        export class Outer {
                            constructor(a: OuterMiddleAA, b: OuterMiddleBBInner) {
                                this._a = a
                                this._b = b
                            }

                            private _a: OuterMiddleAA;

                            get a(): OuterMiddleAA {
                                return this._a
                            }

                            set a(a: OuterMiddleAA) {
                                this._a = a
                            }

                            private _b: OuterMiddleBBInner;

                            get b(): OuterMiddleBBInner {
                                return this._b
                            }

                            set b(b: OuterMiddleBBInner) {
                                this._b = b
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = this._a.encode(encoded)
                                encoded = this._b.encode(encoded)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: Outer
                                    } {
                                let decoded = buf
                                const a = OuterMiddleAA.decode(decoded)
                                decoded = a.buf
                                const b = OuterMiddleBBInner.decode(decoded)
                                decoded = b.buf
                                return {
                                      buf: decoded,
                                      value: new Outer(a.value,b.value)
                                    }
                            }
                        }

                        export class OuterMiddleAA {
                            constructor(a: OuterMiddleAAInner) {
                                this._a = a
                            }

                            private _a: OuterMiddleAAInner;

                            get a(): OuterMiddleAAInner {
                                return this._a
                            }

                            set a(a: OuterMiddleAAInner) {
                                this._a = a
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = this._a.encode(encoded)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleAA
                                    } {
                                let decoded = buf
                                const a = OuterMiddleAAInner.decode(decoded)
                                decoded = a.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleAA(a.value)
                                    }
                            }
                        }

                        export class OuterMiddleAAInner {
                            constructor(a: bigint, b: boolean) {
                                this._a = a
                                this._b = b
                            }

                            private _a: bigint;

                            get a(): bigint {
                                return this._a
                            }

                            set a(a: bigint) {
                                this._a = a
                            }

                            private _b: boolean;

                            get b(): boolean {
                                return this._b
                            }

                            set b(b: boolean) {
                                this._b = b
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeInt64(encoded, this._a)
                                encoded = encodeBoolean(encoded, this._b)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleAAInner
                                    } {
                                let decoded = buf
                                const a = decodeInt64(decoded)
                                decoded = a.buf
                                const b = decodeBoolean(decoded)
                                decoded = b.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleAAInner(a.value,b.value)
                                    }
                            }
                        }

                        export class OuterMiddleBB {
                            constructor(a: OuterMiddleBBInner) {
                                this._a = a
                            }

                            private _a: OuterMiddleBBInner;

                            get a(): OuterMiddleBBInner {
                                return this._a
                            }

                            set a(a: OuterMiddleBBInner) {
                                this._a = a
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = this._a.encode(encoded)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleBB
                                    } {
                                let decoded = buf
                                const a = OuterMiddleBBInner.decode(decoded)
                                decoded = a.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleBB(a.value)
                                    }
                            }
                        }

                        export class OuterMiddleBBInner {
                            constructor(a: number, b: boolean) {
                                this._a = a
                                this._b = b
                            }

                            private _a: number;

                            get a(): number {
                                return this._a
                            }

                            set a(a: number) {
                                this._a = a
                            }

                            private _b: boolean;

                            get b(): boolean {
                                return this._b
                            }

                            set b(b: boolean) {
                                this._b = b
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeInt32(encoded, this._a)
                                encoded = encodeBoolean(encoded, this._b)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleBBInner
                                    } {
                                let decoded = buf
                                const a = decodeInt32(decoded)
                                decoded = a.buf
                                const b = decodeBoolean(decoded)
                                decoded = b.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleBBInner(a.value,b.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_reference_outside.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace reference {
                        export namespace outside {
                            export class Second {
                                constructor(a: OuterInner) {
                                    this._a = a
                                }

                                private _a: OuterInner;

                                get a(): OuterInner {
                                    return this._a
                                }

                                set a(a: OuterInner) {
                                    this._a = a
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = this._a.encode(encoded)
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: Second
                                        } {
                                    let decoded = buf
                                    const a = OuterInner.decode(decoded)
                                    decoded = a.buf
                                    return {
                                          buf: decoded,
                                          value: new Second(a.value)
                                        }
                                }
                            }

                            export class Outer {
                                constructor() {
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: Outer
                                        } {
                                    let decoded = buf
                                    return {
                                          buf: decoded,
                                          value: new Outer()
                                        }
                                }
                            }

                            export class OuterInner {
                                constructor(a: string) {
                                    this._a = a
                                }

                                private _a: string;

                                get a(): string {
                                    return this._a
                                }

                                set a(a: string) {
                                    this._a = a
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeString(encoded, this._a)
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: OuterInner
                                        } {
                                    let decoded = buf
                                    const a = decodeString(decoded)
                                    decoded = a.buf
                                    return {
                                          buf: decoded,
                                          value: new OuterInner(a.value)
                                        }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_reference_outside_enum.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeUint8, decodeUint8 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace reference {
                        export namespace outside {
                            export namespace enm {
                                enum OuterCorpus {
                                    UNIVERSAL = 0,
                                    WEB = 1,
                                    IMAGES = 2,
                                    LOCAL = 3,
                                    NEWS = 4,
                                    PRODUCTS = 5,
                                    VIDEO = 6
                                }

                                export class Second {
                                    constructor(a: OuterCorpus) {
                                        this._a = a
                                    }

                                    private _a: OuterCorpus;

                                    get a(): OuterCorpus {
                                        return this._a
                                    }

                                    set a(a: OuterCorpus) {
                                        this._a = a
                                    }

                                    encode(buf: Uint8Array): Uint8Array {
                                        let encoded = buf
                                        encoded = encodeUint8(encoded, this._a as number)
                                        return encoded
                                    }

                                    static decode(buf: Uint8Array): {
                                              buf: Uint8Array,
                                              value: Second
                                            } {
                                        let decoded = buf
                                        const aUint8 = decodeUint8(decoded)
                                        const a = { value: aUint8.value as OuterCorpus }

                                        decoded = aUint8.buf
                                        return {
                                              buf: decoded,
                                              value: new Second(a.value)
                                            }
                                    }
                                }

                                export class Outer {
                                    constructor() {
                                    }

                                    encode(buf: Uint8Array): Uint8Array {
                                        let encoded = buf
                                        return encoded
                                    }

                                    static decode(buf: Uint8Array): {
                                              buf: Uint8Array,
                                              value: Outer
                                            } {
                                        let decoded = buf
                                        return {
                                              buf: decoded,
                                              value: new Outer()
                                            }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_reference_outside_hoisted.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace reference {
                        export namespace outside {
                            export namespace hoisted {
                                export class Outer {
                                    constructor() {
                                    }

                                    encode(buf: Uint8Array): Uint8Array {
                                        let encoded = buf
                                        return encoded
                                    }

                                    static decode(buf: Uint8Array): {
                                              buf: Uint8Array,
                                              value: Outer
                                            } {
                                        let decoded = buf
                                        return {
                                              buf: decoded,
                                              value: new Outer()
                                            }
                                    }
                                }

                                export class OuterInner {
                                    constructor(a: string) {
                                        this._a = a
                                    }

                                    private _a: string;

                                    get a(): string {
                                        return this._a
                                    }

                                    set a(a: string) {
                                        this._a = a
                                    }

                                    encode(buf: Uint8Array): Uint8Array {
                                        let encoded = buf
                                        encoded = encodeString(encoded, this._a)
                                        return encoded
                                    }

                                    static decode(buf: Uint8Array): {
                                              buf: Uint8Array,
                                              value: OuterInner
                                            } {
                                        let decoded = buf
                                        const a = decodeString(decoded)
                                        decoded = a.buf
                                        return {
                                              buf: decoded,
                                              value: new OuterInner(a.value)
                                            }
                                    }
                                }

                                export class Second {
                                    constructor(a: OuterInner) {
                                        this._a = a
                                    }

                                    private _a: OuterInner;

                                    get a(): OuterInner {
                                        return this._a
                                    }

                                    set a(a: OuterInner) {
                                        this._a = a
                                    }

                                    encode(buf: Uint8Array): Uint8Array {
                                        let encoded = buf
                                        encoded = this._a.encode(encoded)
                                        return encoded
                                    }

                                    static decode(buf: Uint8Array): {
                                              buf: Uint8Array,
                                              value: Second
                                            } {
                                        let decoded = buf
                                        const a = OuterInner.decode(decoded)
                                        decoded = a.buf
                                        return {
                                              buf: decoded,
                                              value: new Second(a.value)
                                            }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nopackage.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt32, decodeInt32 } from \\"polyglot-ts\\";

export class User {
    constructor(name: string, age: number, department: Department) {
        this._name = name
        this._age = age
        this._department = department
    }

    private _name: string;

    get name(): string {
        return this._name
    }

    set name(name: string) {
        this._name = name
    }

    private _age: number;

    get age(): number {
        return this._age
    }

    set age(age: number) {
        this._age = age
    }

    private _department: Department;

    get department(): Department {
        return this._department
    }

    set department(department: Department) {
        this._department = department
    }

    encode(buf: Uint8Array): Uint8Array {
        let encoded = buf
        encoded = encodeString(encoded, this._name)
        encoded = encodeInt32(encoded, this._age)
        encoded = this._department.encode(encoded)
        return encoded
    }

    static decode(buf: Uint8Array): {
              buf: Uint8Array,
              value: User
            } {
        let decoded = buf
        const name = decodeString(decoded)
        decoded = name.buf
        const age = decodeInt32(decoded)
        decoded = age.buf
        const department = Department.decode(decoded)
        decoded = department.buf
        return {
              buf: decoded,
              value: new User(name.value,age.value,department.value)
            }
    }
}

export class Department {
    constructor(name: string) {
        this._name = name
    }

    private _name: string;

    get name(): string {
        return this._name
    }

    set name(name: string) {
        this._name = name
    }

    encode(buf: Uint8Array): Uint8Array {
        let encoded = buf
        encoded = encodeString(encoded, this._name)
        return encoded
    }

    static decode(buf: Uint8Array): {
              buf: Uint8Array,
              value: Department
            } {
        let decoded = buf
        const name = decodeString(decoded)
        decoded = name.buf
        return {
              buf: decoded,
              value: new Department(name.value)
            }
    }
}
"
`;

exports[`Generator Can generate TypeScript for oneof.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace oneof {
                        export class SampleMessage {
                            constructor(name: string, potato: string) {
                                this._name = name
                                this._potato = potato
                            }

                            private _name: string;

                            get name(): string {
                                return this._name
                            }

                            set name(name: string) {
                                this._name = name
                            }

                            private _potato: string;

                            get potato(): string {
                                return this._potato
                            }

                            set potato(potato: string) {
                                this._potato = potato
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._name)
                                encoded = encodeString(encoded, this._potato)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: SampleMessage
                                    } {
                                let decoded = buf
                                const name = decodeString(decoded)
                                decoded = name.buf
                                const potato = decodeString(decoded)
                                decoded = potato.buf
                                return {
                                      buf: decoded,
                                      value: new SampleMessage(name.value,potato.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for order.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString, encodeUint8, encodeArray, Kind, encodeMap, decodeUint8, decodeArray, decodeMap } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace order {
                        enum MessageType {
                            MESSAGE_TYPE_A = 0,
                            MESSAGE_TYPE_B = 1,
                            MESSAGE_TYPE_C = 2
                        }

                        export class ExampleMessage {
                            constructor(a: string, b: MessageType, c: string[], e: SecondExampleMessage, d: Map<string, string>) {
                                this._a = a
                                this._b = b
                                this._c = c
                                this._e = e
                                this._d = d
                            }

                            private _a: string;

                            get a(): string {
                                return this._a
                            }

                            set a(a: string) {
                                this._a = a
                            }

                            private _b: MessageType;

                            get b(): MessageType {
                                return this._b
                            }

                            set b(b: MessageType) {
                                this._b = b
                            }

                            private _c: string[];

                            get c(): string[] {
                                return this._c
                            }

                            set c(c: string[]) {
                                this._c = c
                            }

                            private _e: SecondExampleMessage;

                            get e(): SecondExampleMessage {
                                return this._e
                            }

                            set e(e: SecondExampleMessage) {
                                this._e = e
                            }

                            private _d: Map<string, string>;

                            get d(): Map<string, string> {
                                return this._d
                            }

                            set d(d: Map<string, string>) {
                                this._d = d
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._a)
                                encoded = encodeUint8(encoded, this._b as number)
                                encoded = encodeArray(encoded, this._c.length, Kind.String)
                                this._c.forEach(field => {
                                                  encoded = encodeString(encoded, field);
                                                })
                                encoded = this._e.encode(encoded)
                                encoded = encodeMap(encoded, this._d.size,
                                              Kind.String,
                                              Kind.String)
                                this._d.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeString(encoded, value);
                                                })
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: ExampleMessage
                                    } {
                                let decoded = buf
                                const a = decodeString(decoded)
                                decoded = a.buf
                                const bUint8 = decodeUint8(decoded)
                                const b = { value: bUint8.value as MessageType }

                                decoded = bUint8.buf
                                const cArray = decodeArray(decoded)
                                decoded = cArray.buf
                                const c: { value: string[] } = {
                                                  value: [],
                                                }

                                for (let i = 0; i < cArray.size; i++) {
                                                  const element = decodeString(decoded);
                                                  decoded = element.buf;
                                                  c.value.push(element.value);
                                                }

                                const e = SecondExampleMessage.decode(decoded)
                                decoded = e.buf
                                const dMap = decodeMap(decoded)
                                decoded = dMap.buf
                                const d: { value: Map<string, string> } = {
                                                  value: new Map<string, string>(),
                                                }

                                for (let i = 0; i < dMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeString(decoded);
                                                  decoded = value.buf;
                                                  d.value.set(key.value, value.value);
                                                }

                                return {
                                      buf: decoded,
                                      value: new ExampleMessage(a.value,b.value,c.value,e.value,d.value)
                                    }
                            }
                        }

                        export class SecondExampleMessage {
                            constructor(a: string) {
                                this._a = a
                            }

                            private _a: string;

                            get a(): string {
                                return this._a
                            }

                            set a(a: string) {
                                this._a = a
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._a)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: SecondExampleMessage
                                    } {
                                let decoded = buf
                                const a = decodeString(decoded)
                                decoded = a.buf
                                return {
                                      buf: decoded,
                                      value: new SecondExampleMessage(a.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for rpc.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace rpc {
                        export class ExampleMessage {
                            constructor(a: string) {
                                this._a = a
                            }

                            private _a: string;

                            get a(): string {
                                return this._a
                            }

                            set a(a: string) {
                                this._a = a
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._a)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: ExampleMessage
                                    } {
                                let decoded = buf
                                const a = decodeString(decoded)
                                decoded = a.buf
                                return {
                                      buf: decoded,
                                      value: new ExampleMessage(a.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for simple.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt32, decodeInt32 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace simple {
                        export class User {
                            constructor(name: string, age: number, department: Department) {
                                this._name = name
                                this._age = age
                                this._department = department
                            }

                            private _name: string;

                            get name(): string {
                                return this._name
                            }

                            set name(name: string) {
                                this._name = name
                            }

                            private _age: number;

                            get age(): number {
                                return this._age
                            }

                            set age(age: number) {
                                this._age = age
                            }

                            private _department: Department;

                            get department(): Department {
                                return this._department
                            }

                            set department(department: Department) {
                                this._department = department
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._name)
                                encoded = encodeInt32(encoded, this._age)
                                encoded = this._department.encode(encoded)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: User
                                    } {
                                let decoded = buf
                                const name = decodeString(decoded)
                                decoded = name.buf
                                const age = decodeInt32(decoded)
                                decoded = age.buf
                                const department = Department.decode(decoded)
                                decoded = department.buf
                                return {
                                      buf: decoded,
                                      value: new User(name.value,age.value,department.value)
                                    }
                            }
                        }

                        export class Department {
                            constructor(name: string) {
                                this._name = name
                            }

                            private _name: string;

                            get name(): string {
                                return this._name
                            }

                            set name(name: string) {
                                this._name = name
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._name)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: Department
                                    } {
                                let decoded = buf
                                const name = decodeString(decoded)
                                decoded = name.buf
                                return {
                                      buf: decoded,
                                      value: new Department(name.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for simple_hoisted.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.1.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt32, decodeInt32 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace simple {
                        export class Department {
                            constructor(name: string) {
                                this._name = name
                            }

                            private _name: string;

                            get name(): string {
                                return this._name
                            }

                            set name(name: string) {
                                this._name = name
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._name)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: Department
                                    } {
                                let decoded = buf
                                const name = decodeString(decoded)
                                decoded = name.buf
                                return {
                                      buf: decoded,
                                      value: new Department(name.value)
                                    }
                            }
                        }

                        export class User {
                            constructor(name: string, age: number, department: Department) {
                                this._name = name
                                this._age = age
                                this._department = department
                            }

                            private _name: string;

                            get name(): string {
                                return this._name
                            }

                            set name(name: string) {
                                this._name = name
                            }

                            private _age: number;

                            get age(): number {
                                return this._age
                            }

                            set age(age: number) {
                                this._age = age
                            }

                            private _department: Department;

                            get department(): Department {
                                return this._department
                            }

                            set department(department: Department) {
                                this._department = department
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._name)
                                encoded = encodeInt32(encoded, this._age)
                                encoded = this._department.encode(encoded)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: User
                                    } {
                                let decoded = buf
                                const name = decodeString(decoded)
                                decoded = name.buf
                                const age = decodeInt32(decoded)
                                decoded = age.buf
                                const department = Department.decode(decoded)
                                decoded = department.buf
                                return {
                                      buf: decoded,
                                      value: new User(name.value,age.value,department.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;
