// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Generator Can generate TypeScript for array.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt32, decodeInt32, encodeArray, Kind, decodeArray } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace array {
                        export class ExampleMessage {
                            constructor(name: string, addresses: string[], balances: number[]) {
                                this._name = name
                                this._addresses = addresses
                                this._balances = balances
                            }

                            private _name: string;

                            get name(): string {
                                return this._name
                            }

                            set name(name: string) {
                                this._name = name
                            }

                            private _addresses: string[];

                            get addresses(): string[] {
                                return this._addresses
                            }

                            set addresses(addresses: string[]) {
                                this._addresses = addresses
                            }

                            private _balances: number[];

                            get balances(): number[] {
                                return this._balances
                            }

                            set balances(balances: number[]) {
                                this._balances = balances
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._name)
                                encoded = encodeArray(encoded, this._addresses.length, Kind.String)
                                this._addresses.forEach(field => {
                                                  encoded = encodeString(encoded, field);
                                                })
                                encoded = encodeArray(encoded, this._balances.length, Kind.Int32)
                                this._balances.forEach(field => {
                                                  encoded = encodeInt32(encoded, field);
                                                })
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: ExampleMessage
                                    } {
                                let decoded = buf
                                const nameTemp = decodeString(decoded)
                                decoded = nameTemp.buf
                                const addressesArray = decodeArray(decoded)
                                decoded = addressesArray.buf
                                const addressesTemp: { value: string[] } = {
                                                  value: [],
                                                }

                                for (let i = 0; i < addressesArray.size; i++) {
                                                  const element = decodeString(decoded);
                                                  decoded = element.buf;
                                                  addressesTemp.value.push(element.value);
                                                }

                                const balancesArray = decodeArray(decoded)
                                decoded = balancesArray.buf
                                const balancesTemp: { value: number[] } = {
                                                  value: [],
                                                }

                                for (let i = 0; i < balancesArray.size; i++) {
                                                  const element = decodeInt32(decoded);
                                                  decoded = element.buf;
                                                  balancesTemp.value.push(element.value);
                                                }

                                return {
                                      buf: decoded,
                                      value: new ExampleMessage(nameTemp.value,addressesTemp.value,balancesTemp.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for array_composite.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt32, decodeInt32, encodeArray, Kind, decodeArray } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace array {
                        export namespace composite {
                            export class ExampleMessage {
                                constructor(name: string, addresses: string[], patients: NestedExampleMessage[]) {
                                    this._name = name
                                    this._addresses = addresses
                                    this._patients = patients
                                }

                                private _name: string;

                                get name(): string {
                                    return this._name
                                }

                                set name(name: string) {
                                    this._name = name
                                }

                                private _addresses: string[];

                                get addresses(): string[] {
                                    return this._addresses
                                }

                                set addresses(addresses: string[]) {
                                    this._addresses = addresses
                                }

                                private _patients: NestedExampleMessage[];

                                get patients(): NestedExampleMessage[] {
                                    return this._patients
                                }

                                set patients(patients: NestedExampleMessage[]) {
                                    this._patients = patients
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeString(encoded, this._name)
                                    encoded = encodeArray(encoded, this._addresses.length, Kind.String)
                                    this._addresses.forEach(field => {
                                                      encoded = encodeString(encoded, field);
                                                    })
                                    encoded = encodeArray(encoded, this._patients.length, Kind.Any)
                                    this._patients.forEach((field) => {
                                                      encoded = field.encode(encoded);
                                                    })
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: ExampleMessage
                                        } {
                                    let decoded = buf
                                    const nameTemp = decodeString(decoded)
                                    decoded = nameTemp.buf
                                    const addressesArray = decodeArray(decoded)
                                    decoded = addressesArray.buf
                                    const addressesTemp: { value: string[] } = {
                                                      value: [],
                                                    }

                                    for (let i = 0; i < addressesArray.size; i++) {
                                                      const element = decodeString(decoded);
                                                      decoded = element.buf;
                                                      addressesTemp.value.push(element.value);
                                                    }

                                    const patientsArray = decodeArray(decoded)
                                    decoded = patientsArray.buf
                                    const patientsTemp: { value: NestedExampleMessage[] } = {
                                                      value: [],
                                                    }

                                    for (let i = 0; i < patientsArray.size; i++) {
                                                      const element = NestedExampleMessage.decode(decoded);
                                                      decoded = element.buf;
                                                      patientsTemp.value.push(element.value);
                                                    }

                                    return {
                                          buf: decoded,
                                          value: new ExampleMessage(nameTemp.value,addressesTemp.value,patientsTemp.value)
                                        }
                                }
                            }

                            export class NestedExampleMessage {
                                constructor(age: number) {
                                    this._age = age
                                }

                                private _age: number;

                                get age(): number {
                                    return this._age
                                }

                                set age(age: number) {
                                    this._age = age
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeInt32(encoded, this._age)
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: NestedExampleMessage
                                        } {
                                    let decoded = buf
                                    const ageTemp = decodeInt32(decoded)
                                    decoded = ageTemp.buf
                                    return {
                                          buf: decoded,
                                          value: new NestedExampleMessage(ageTemp.value)
                                        }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for array_enum.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString, encodeArray, Kind, encodeUint8, decodeArray, decodeUint8 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace array {
                        export namespace enm {
                            enum MessageType {
                                MESSAGE_TYPE_A = 0,
                                MESSAGE_TYPE_B = 1,
                                MESSAGE_TYPE_C = 2
                            }

                            export class ExampleMessage {
                                constructor(name: string, addresses: string[], patients: MessageType[]) {
                                    this._name = name
                                    this._addresses = addresses
                                    this._patients = patients
                                }

                                private _name: string;

                                get name(): string {
                                    return this._name
                                }

                                set name(name: string) {
                                    this._name = name
                                }

                                private _addresses: string[];

                                get addresses(): string[] {
                                    return this._addresses
                                }

                                set addresses(addresses: string[]) {
                                    this._addresses = addresses
                                }

                                private _patients: MessageType[];

                                get patients(): MessageType[] {
                                    return this._patients
                                }

                                set patients(patients: MessageType[]) {
                                    this._patients = patients
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeString(encoded, this._name)
                                    encoded = encodeArray(encoded, this._addresses.length, Kind.String)
                                    this._addresses.forEach(field => {
                                                      encoded = encodeString(encoded, field);
                                                    })
                                    encoded = encodeArray(encoded, this._patients.length, Kind.Any)
                                    this._patients.forEach(field => {
                                                      encoded = encodeUint8(encoded, field as number);
                                                    })
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: ExampleMessage
                                        } {
                                    let decoded = buf
                                    const nameTemp = decodeString(decoded)
                                    decoded = nameTemp.buf
                                    const addressesArray = decodeArray(decoded)
                                    decoded = addressesArray.buf
                                    const addressesTemp: { value: string[] } = {
                                                      value: [],
                                                    }

                                    for (let i = 0; i < addressesArray.size; i++) {
                                                      const element = decodeString(decoded);
                                                      decoded = element.buf;
                                                      addressesTemp.value.push(element.value);
                                                    }

                                    const patientsArray = decodeArray(decoded)
                                    decoded = patientsArray.buf
                                    const patientsTemp: { value: MessageType[] } = {
                                                      value: [],
                                                    }

                                    for (let i = 0; i < patientsArray.size; i++) {
                                                      const element = decodeUint8(decoded);
                                                      decoded = element.buf;
                                                      patientsTemp.value.push(element.value as MessageType);
                                                    }

                                    return {
                                          buf: decoded,
                                          value: new ExampleMessage(nameTemp.value,addressesTemp.value,patientsTemp.value)
                                        }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for complete.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt64, decodeInt64, encodeBoolean, decodeBoolean, encodeInt32, decodeInt32, encodeFloat64, decodeFloat64, encodeUint8, decodeUint8, encodeArray, Kind, decodeArray, encodeMap, decodeMap } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace complete {
                    enum RequestCorpus {
                        UNIVERSAL = 0,
                        WEB = 1,
                        IMAGES = 2,
                        LOCAL = 3,
                        NEWS = 4,
                        PRODUCTS = 5,
                        VIDEO = 6
                    }

                    enum Test {
                        Potato = 0,
                        Monkey = 1
                    }

                    enum MyMessage1EnumAllowingAlias {
                        UNKNOWN = 0,
                        STARTED = 1,
                        RUNNING = 2
                    }

                    enum MyMessage2EnumNotAllowingAlias {
                        UNKNOWN = 0,
                        STARTED = 1
                    }

                    export class Request {
                        constructor(Message: string, corpus: RequestCorpus) {
                            this._Message = Message
                            this._corpus = corpus
                        }

                        private _Message: string;

                        get Message(): string {
                            return this._Message
                        }

                        set Message(Message: string) {
                            this._Message = Message
                        }

                        private _corpus: RequestCorpus;

                        get corpus(): RequestCorpus {
                            return this._corpus
                        }

                        set corpus(corpus: RequestCorpus) {
                            this._corpus = corpus
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeString(encoded, this._Message)
                            encoded = encodeUint8(encoded, this._corpus as number)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: Request
                                } {
                            let decoded = buf
                            const MessageTemp = decodeString(decoded)
                            decoded = MessageTemp.buf
                            const corpusUint8 = decodeUint8(decoded)
                            const corpusTemp = { value: corpusUint8.value as RequestCorpus }

                            decoded = corpusUint8.buf
                            return {
                                  buf: decoded,
                                  value: new Request(MessageTemp.value,corpusTemp.value)
                                }
                        }
                    }

                    export class Response {
                        constructor(Message: string, Test: Data) {
                            this._Message = Message
                            this._Test = Test
                        }

                        private _Message: string;

                        get Message(): string {
                            return this._Message
                        }

                        set Message(Message: string) {
                            this._Message = Message
                        }

                        private _Test: Data;

                        get Test(): Data {
                            return this._Test
                        }

                        set Test(Test: Data) {
                            this._Test = Test
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeString(encoded, this._Message)
                            encoded = this._Test.encode(encoded)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: Response
                                } {
                            let decoded = buf
                            const MessageTemp = decodeString(decoded)
                            decoded = MessageTemp.buf
                            const TestTemp = Data.decode(decoded)
                            decoded = TestTemp.buf
                            return {
                                  buf: decoded,
                                  value: new Response(MessageTemp.value,TestTemp.value)
                                }
                        }
                    }

                    export class Data {
                        constructor(Message: string, Checker: Test) {
                            this._Message = Message
                            this._Checker = Checker
                        }

                        private _Message: string;

                        get Message(): string {
                            return this._Message
                        }

                        set Message(Message: string) {
                            this._Message = Message
                        }

                        private _Checker: Test;

                        get Checker(): Test {
                            return this._Checker
                        }

                        set Checker(Checker: Test) {
                            this._Checker = Checker
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeString(encoded, this._Message)
                            encoded = encodeUint8(encoded, this._Checker as number)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: Data
                                } {
                            let decoded = buf
                            const MessageTemp = decodeString(decoded)
                            decoded = MessageTemp.buf
                            const CheckerUint8 = decodeUint8(decoded)
                            const CheckerTemp = { value: CheckerUint8.value as Test }

                            decoded = CheckerUint8.buf
                            return {
                                  buf: decoded,
                                  value: new Data(MessageTemp.value,CheckerTemp.value)
                                }
                        }
                    }

                    export class MyMessage1 {
                        constructor() {
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: MyMessage1
                                } {
                            let decoded = buf
                            return {
                                  buf: decoded,
                                  value: new MyMessage1()
                                }
                        }
                    }

                    export class MyMessage2 {
                        constructor() {
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: MyMessage2
                                } {
                            let decoded = buf
                            return {
                                  buf: decoded,
                                  value: new MyMessage2()
                                }
                        }
                    }

                    export class SearchResponse {
                        constructor(results: SearchResponseResult[], results2: SearchResponseResult[], snippets: string[], snippets2: string[]) {
                            this._results = results
                            this._results2 = results2
                            this._snippets = snippets
                            this._snippets2 = snippets2
                        }

                        private _results: SearchResponseResult[];

                        get results(): SearchResponseResult[] {
                            return this._results
                        }

                        set results(results: SearchResponseResult[]) {
                            this._results = results
                        }

                        private _results2: SearchResponseResult[];

                        get results2(): SearchResponseResult[] {
                            return this._results2
                        }

                        set results2(results2: SearchResponseResult[]) {
                            this._results2 = results2
                        }

                        private _snippets: string[];

                        get snippets(): string[] {
                            return this._snippets
                        }

                        set snippets(snippets: string[]) {
                            this._snippets = snippets
                        }

                        private _snippets2: string[];

                        get snippets2(): string[] {
                            return this._snippets2
                        }

                        set snippets2(snippets2: string[]) {
                            this._snippets2 = snippets2
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeArray(encoded, this._results.length, Kind.Any)
                            this._results.forEach((field) => {
                                              encoded = field.encode(encoded);
                                            })
                            encoded = encodeArray(encoded, this._results2.length, Kind.Any)
                            this._results2.forEach((field) => {
                                              encoded = field.encode(encoded);
                                            })
                            encoded = encodeArray(encoded, this._snippets.length, Kind.String)
                            this._snippets.forEach(field => {
                                              encoded = encodeString(encoded, field);
                                            })
                            encoded = encodeArray(encoded, this._snippets2.length, Kind.String)
                            this._snippets2.forEach(field => {
                                              encoded = encodeString(encoded, field);
                                            })
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: SearchResponse
                                } {
                            let decoded = buf
                            const resultsArray = decodeArray(decoded)
                            decoded = resultsArray.buf
                            const resultsTemp: { value: SearchResponseResult[] } = {
                                              value: [],
                                            }

                            for (let i = 0; i < resultsArray.size; i++) {
                                              const element = SearchResponseResult.decode(decoded);
                                              decoded = element.buf;
                                              resultsTemp.value.push(element.value);
                                            }

                            const results2Array = decodeArray(decoded)
                            decoded = results2Array.buf
                            const results2Temp: { value: SearchResponseResult[] } = {
                                              value: [],
                                            }

                            for (let i = 0; i < results2Array.size; i++) {
                                              const element = SearchResponseResult.decode(decoded);
                                              decoded = element.buf;
                                              results2Temp.value.push(element.value);
                                            }

                            const snippetsArray = decodeArray(decoded)
                            decoded = snippetsArray.buf
                            const snippetsTemp: { value: string[] } = {
                                              value: [],
                                            }

                            for (let i = 0; i < snippetsArray.size; i++) {
                                              const element = decodeString(decoded);
                                              decoded = element.buf;
                                              snippetsTemp.value.push(element.value);
                                            }

                            const snippets2Array = decodeArray(decoded)
                            decoded = snippets2Array.buf
                            const snippets2Temp: { value: string[] } = {
                                              value: [],
                                            }

                            for (let i = 0; i < snippets2Array.size; i++) {
                                              const element = decodeString(decoded);
                                              decoded = element.buf;
                                              snippets2Temp.value.push(element.value);
                                            }

                            return {
                                  buf: decoded,
                                  value: new SearchResponse(resultsTemp.value,results2Temp.value,snippetsTemp.value,snippets2Temp.value)
                                }
                        }
                    }

                    export class SearchResponseResult {
                        constructor(url: string, title: string, snippets: string[]) {
                            this._url = url
                            this._title = title
                            this._snippets = snippets
                        }

                        private _url: string;

                        get url(): string {
                            return this._url
                        }

                        set url(url: string) {
                            this._url = url
                        }

                        private _title: string;

                        get title(): string {
                            return this._title
                        }

                        set title(title: string) {
                            this._title = title
                        }

                        private _snippets: string[];

                        get snippets(): string[] {
                            return this._snippets
                        }

                        set snippets(snippets: string[]) {
                            this._snippets = snippets
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeString(encoded, this._url)
                            encoded = encodeString(encoded, this._title)
                            encoded = encodeArray(encoded, this._snippets.length, Kind.String)
                            this._snippets.forEach(field => {
                                              encoded = encodeString(encoded, field);
                                            })
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: SearchResponseResult
                                } {
                            let decoded = buf
                            const urlTemp = decodeString(decoded)
                            decoded = urlTemp.buf
                            const titleTemp = decodeString(decoded)
                            decoded = titleTemp.buf
                            const snippetsArray = decodeArray(decoded)
                            decoded = snippetsArray.buf
                            const snippetsTemp: { value: string[] } = {
                                              value: [],
                                            }

                            for (let i = 0; i < snippetsArray.size; i++) {
                                              const element = decodeString(decoded);
                                              decoded = element.buf;
                                              snippetsTemp.value.push(element.value);
                                            }

                            return {
                                  buf: decoded,
                                  value: new SearchResponseResult(urlTemp.value,titleTemp.value,snippetsTemp.value)
                                }
                        }
                    }

                    export class Resulting {
                        constructor(url: string, title: string, snippets: string[]) {
                            this._url = url
                            this._title = title
                            this._snippets = snippets
                        }

                        private _url: string;

                        get url(): string {
                            return this._url
                        }

                        set url(url: string) {
                            this._url = url
                        }

                        private _title: string;

                        get title(): string {
                            return this._title
                        }

                        set title(title: string) {
                            this._title = title
                        }

                        private _snippets: string[];

                        get snippets(): string[] {
                            return this._snippets
                        }

                        set snippets(snippets: string[]) {
                            this._snippets = snippets
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeString(encoded, this._url)
                            encoded = encodeString(encoded, this._title)
                            encoded = encodeArray(encoded, this._snippets.length, Kind.String)
                            this._snippets.forEach(field => {
                                              encoded = encodeString(encoded, field);
                                            })
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: Resulting
                                } {
                            let decoded = buf
                            const urlTemp = decodeString(decoded)
                            decoded = urlTemp.buf
                            const titleTemp = decodeString(decoded)
                            decoded = titleTemp.buf
                            const snippetsArray = decodeArray(decoded)
                            decoded = snippetsArray.buf
                            const snippetsTemp: { value: string[] } = {
                                              value: [],
                                            }

                            for (let i = 0; i < snippetsArray.size; i++) {
                                              const element = decodeString(decoded);
                                              decoded = element.buf;
                                              snippetsTemp.value.push(element.value);
                                            }

                            return {
                                  buf: decoded,
                                  value: new Resulting(urlTemp.value,titleTemp.value,snippetsTemp.value)
                                }
                        }
                    }

                    export class SomeOtherMessage {
                        constructor(result: SearchResponseResult) {
                            this._result = result
                        }

                        private _result: SearchResponseResult;

                        get result(): SearchResponseResult {
                            return this._result
                        }

                        set result(result: SearchResponseResult) {
                            this._result = result
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = this._result.encode(encoded)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: SomeOtherMessage
                                } {
                            let decoded = buf
                            const resultTemp = SearchResponseResult.decode(decoded)
                            decoded = resultTemp.buf
                            return {
                                  buf: decoded,
                                  value: new SomeOtherMessage(resultTemp.value)
                                }
                        }
                    }

                    export class Outer {
                        constructor(a: OuterMiddleAA, b: OuterMiddleBB) {
                            this._a = a
                            this._b = b
                        }

                        private _a: OuterMiddleAA;

                        get a(): OuterMiddleAA {
                            return this._a
                        }

                        set a(a: OuterMiddleAA) {
                            this._a = a
                        }

                        private _b: OuterMiddleBB;

                        get b(): OuterMiddleBB {
                            return this._b
                        }

                        set b(b: OuterMiddleBB) {
                            this._b = b
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = this._a.encode(encoded)
                            encoded = this._b.encode(encoded)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: Outer
                                } {
                            let decoded = buf
                            const aTemp = OuterMiddleAA.decode(decoded)
                            decoded = aTemp.buf
                            const bTemp = OuterMiddleBB.decode(decoded)
                            decoded = bTemp.buf
                            return {
                                  buf: decoded,
                                  value: new Outer(aTemp.value,bTemp.value)
                                }
                        }
                    }

                    export class OuterMiddleAA {
                        constructor(inner: OuterMiddleAAInner) {
                            this._inner = inner
                        }

                        private _inner: OuterMiddleAAInner;

                        get inner(): OuterMiddleAAInner {
                            return this._inner
                        }

                        set inner(inner: OuterMiddleAAInner) {
                            this._inner = inner
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = this._inner.encode(encoded)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: OuterMiddleAA
                                } {
                            let decoded = buf
                            const innerTemp = OuterMiddleAAInner.decode(decoded)
                            decoded = innerTemp.buf
                            return {
                                  buf: decoded,
                                  value: new OuterMiddleAA(innerTemp.value)
                                }
                        }
                    }

                    export class OuterMiddleAAInner {
                        constructor(ival: bigint, booly: boolean) {
                            this._ival = ival
                            this._booly = booly
                        }

                        private _ival: bigint;

                        get ival(): bigint {
                            return this._ival
                        }

                        set ival(ival: bigint) {
                            this._ival = ival
                        }

                        private _booly: boolean;

                        get booly(): boolean {
                            return this._booly
                        }

                        set booly(booly: boolean) {
                            this._booly = booly
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeInt64(encoded, this._ival)
                            encoded = encodeBoolean(encoded, this._booly)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: OuterMiddleAAInner
                                } {
                            let decoded = buf
                            const ivalTemp = decodeInt64(decoded)
                            decoded = ivalTemp.buf
                            const boolyTemp = decodeBoolean(decoded)
                            decoded = boolyTemp.buf
                            return {
                                  buf: decoded,
                                  value: new OuterMiddleAAInner(ivalTemp.value,boolyTemp.value)
                                }
                        }
                    }

                    export class OuterMiddleBB {
                        constructor(inner: OuterMiddleBBInner) {
                            this._inner = inner
                        }

                        private _inner: OuterMiddleBBInner;

                        get inner(): OuterMiddleBBInner {
                            return this._inner
                        }

                        set inner(inner: OuterMiddleBBInner) {
                            this._inner = inner
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = this._inner.encode(encoded)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: OuterMiddleBB
                                } {
                            let decoded = buf
                            const innerTemp = OuterMiddleBBInner.decode(decoded)
                            decoded = innerTemp.buf
                            return {
                                  buf: decoded,
                                  value: new OuterMiddleBB(innerTemp.value)
                                }
                        }
                    }

                    export class OuterMiddleBBInner {
                        constructor(ival: number, booly: boolean) {
                            this._ival = ival
                            this._booly = booly
                        }

                        private _ival: number;

                        get ival(): number {
                            return this._ival
                        }

                        set ival(ival: number) {
                            this._ival = ival
                        }

                        private _booly: boolean;

                        get booly(): boolean {
                            return this._booly
                        }

                        set booly(booly: boolean) {
                            this._booly = booly
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeInt32(encoded, this._ival)
                            encoded = encodeBoolean(encoded, this._booly)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: OuterMiddleBBInner
                                } {
                            let decoded = buf
                            const ivalTemp = decodeInt32(decoded)
                            decoded = ivalTemp.buf
                            const boolyTemp = decodeBoolean(decoded)
                            decoded = boolyTemp.buf
                            return {
                                  buf: decoded,
                                  value: new OuterMiddleBBInner(ivalTemp.value,boolyTemp.value)
                                }
                        }
                    }

                    export class SampleMessage {
                        constructor(name: string, potato: string) {
                            this._name = name
                            this._potato = potato
                        }

                        private _name: string;

                        get name(): string {
                            return this._name
                        }

                        set name(name: string) {
                            this._name = name
                        }

                        private _potato: string;

                        get potato(): string {
                            return this._potato
                        }

                        set potato(potato: string) {
                            this._potato = potato
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeString(encoded, this._name)
                            encoded = encodeString(encoded, this._potato)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: SampleMessage
                                } {
                            let decoded = buf
                            const nameTemp = decodeString(decoded)
                            decoded = nameTemp.buf
                            const potatoTemp = decodeString(decoded)
                            decoded = potatoTemp.buf
                            return {
                                  buf: decoded,
                                  value: new SampleMessage(nameTemp.value,potatoTemp.value)
                                }
                        }
                    }

                    export class TestPotato {
                        constructor(prices: Map<string, Test>) {
                            this._prices = prices
                        }

                        private _prices: Map<string, Test>;

                        get prices(): Map<string, Test> {
                            return this._prices
                        }

                        set prices(prices: Map<string, Test>) {
                            this._prices = prices
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeMap(encoded, this._prices.size,
                                          Kind.String, Kind.Any)
                            this._prices.forEach((value, key) => {
                                              encoded = encodeString(encoded, key);
                                              encoded = encodeUint8(encoded, value as number);
                                            })
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: TestPotato
                                } {
                            let decoded = buf
                            const pricesMap = decodeMap(decoded)
                            decoded = pricesMap.buf
                            const prices: { value: Map<string, Test> } = {
                                              value: new Map<string, Test>(),
                                            }

                            for (let i = 0; i < pricesMap.size; i++) {
                                              const key = decodeString(decoded);
                                              decoded = key.buf;
                                              const value = decodeUint8(decoded);
                                              decoded = value.buf;
                                              pricesTemp.value.set(key.value, value.value as Test);
                                            }

                            return {
                                  buf: decoded,
                                  value: new TestPotato(pricesTemp.value)
                                }
                        }
                    }

                    export class StockPrices {
                        constructor(prices: Map<string, number>) {
                            this._prices = prices
                        }

                        private _prices: Map<string, number>;

                        get prices(): Map<string, number> {
                            return this._prices
                        }

                        set prices(prices: Map<string, number>) {
                            this._prices = prices
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeMap(encoded, this._prices.size,
                                          Kind.String,
                                          Kind.Float64)
                            this._prices.forEach((value, key) => {
                                              encoded = encodeString(encoded, key);
                                              encoded = encodeFloat64(encoded, value);
                                            })
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: StockPrices
                                } {
                            let decoded = buf
                            const pricesMap = decodeMap(decoded)
                            decoded = pricesMap.buf
                            const prices: { value: Map<string, number> } = {
                                              value: new Map<string, number>(),
                                            }

                            for (let i = 0; i < pricesMap.size; i++) {
                                              const key = decodeString(decoded);
                                              decoded = key.buf;
                                              const value = decodeFloat64(decoded);
                                              decoded = value.buf;
                                              pricesTemp.value.set(key.value, value.value);
                                            }

                            return {
                                  buf: decoded,
                                  value: new StockPrices(pricesTemp.value)
                                }
                        }
                    }

                    export class StockPricesWrapper {
                        constructor(sPrices: StockPrices[]) {
                            this._sPrices = sPrices
                        }

                        private _sPrices: StockPrices[];

                        get sPrices(): StockPrices[] {
                            return this._sPrices
                        }

                        set sPrices(sPrices: StockPrices[]) {
                            this._sPrices = sPrices
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeArray(encoded, this._sPrices.length, Kind.Any)
                            this._sPrices.forEach((field) => {
                                              encoded = field.encode(encoded);
                                            })
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: StockPricesWrapper
                                } {
                            let decoded = buf
                            const sPricesArray = decodeArray(decoded)
                            decoded = sPricesArray.buf
                            const sPricesTemp: { value: StockPrices[] } = {
                                              value: [],
                                            }

                            for (let i = 0; i < sPricesArray.size; i++) {
                                              const element = StockPrices.decode(decoded);
                                              decoded = element.buf;
                                              sPricesTemp.value.push(element.value);
                                            }

                            return {
                                  buf: decoded,
                                  value: new StockPricesWrapper(sPricesTemp.value)
                                }
                        }
                    }

                    export class StockPricesSuperWrap {
                        constructor(prices: Map<string, StockPricesWrapper>) {
                            this._prices = prices
                        }

                        private _prices: Map<string, StockPricesWrapper>;

                        get prices(): Map<string, StockPricesWrapper> {
                            return this._prices
                        }

                        set prices(prices: Map<string, StockPricesWrapper>) {
                            this._prices = prices
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeMap(encoded, this._prices.size,
                                          Kind.String, Kind.Any)
                            this._prices.forEach((value, key) => {
                                              encoded = encodeString(encoded, key);
                                              encoded = value.encode(encoded);
                                            })
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: StockPricesSuperWrap
                                } {
                            let decoded = buf
                            const pricesMap = decodeMap(decoded)
                            decoded = pricesMap.buf
                            const prices: { value: Map<string, StockPricesWrapper> } = {
                                              value: new Map<string, StockPricesWrapper>(),
                                            }

                            for (let i = 0; i < pricesMap.size; i++) {
                                              const key = decodeString(decoded);
                                              decoded = key.buf;
                                              const value = StockPricesWrapper.decode(decoded);
                                              decoded = value.buf;
                                              pricesTemp.value.set(key.value, value.value);
                                            }

                            return {
                                  buf: decoded,
                                  value: new StockPricesSuperWrap(pricesTemp.value)
                                }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for complex.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeFloat64, decodeFloat64, encodeFloat32, decodeFloat32, encodeInt64, decodeInt64, encodeInt32, decodeInt32, encodeUint32, decodeUint32, encodeUint64, decodeUint64, encodeBoolean, decodeBoolean, encodeString, decodeString, encodeUint8Array, decodeUint8Array } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace complex {
                        export class ExampleMessage {
                            constructor(a: number, b: number, d: bigint, g: number, c: number, e: number, f: bigint, i: number, j: bigint, m: boolean, k: number, l: bigint, h: bigint, n: string, o: Uint8Array) {
                                this._a = a
                                this._b = b
                                this._d = d
                                this._g = g
                                this._c = c
                                this._e = e
                                this._f = f
                                this._i = i
                                this._j = j
                                this._m = m
                                this._k = k
                                this._l = l
                                this._h = h
                                this._n = n
                                this._o = o
                            }

                            private _a: number;

                            get a(): number {
                                return this._a
                            }

                            set a(a: number) {
                                this._a = a
                            }

                            private _b: number;

                            get b(): number {
                                return this._b
                            }

                            set b(b: number) {
                                this._b = b
                            }

                            private _d: bigint;

                            get d(): bigint {
                                return this._d
                            }

                            set d(d: bigint) {
                                this._d = d
                            }

                            private _g: number;

                            get g(): number {
                                return this._g
                            }

                            set g(g: number) {
                                this._g = g
                            }

                            private _c: number;

                            get c(): number {
                                return this._c
                            }

                            set c(c: number) {
                                this._c = c
                            }

                            private _e: number;

                            get e(): number {
                                return this._e
                            }

                            set e(e: number) {
                                this._e = e
                            }

                            private _f: bigint;

                            get f(): bigint {
                                return this._f
                            }

                            set f(f: bigint) {
                                this._f = f
                            }

                            private _i: number;

                            get i(): number {
                                return this._i
                            }

                            set i(i: number) {
                                this._i = i
                            }

                            private _j: bigint;

                            get j(): bigint {
                                return this._j
                            }

                            set j(j: bigint) {
                                this._j = j
                            }

                            private _m: boolean;

                            get m(): boolean {
                                return this._m
                            }

                            set m(m: boolean) {
                                this._m = m
                            }

                            private _k: number;

                            get k(): number {
                                return this._k
                            }

                            set k(k: number) {
                                this._k = k
                            }

                            private _l: bigint;

                            get l(): bigint {
                                return this._l
                            }

                            set l(l: bigint) {
                                this._l = l
                            }

                            private _h: bigint;

                            get h(): bigint {
                                return this._h
                            }

                            set h(h: bigint) {
                                this._h = h
                            }

                            private _n: string;

                            get n(): string {
                                return this._n
                            }

                            set n(n: string) {
                                this._n = n
                            }

                            private _o: Uint8Array;

                            get o(): Uint8Array {
                                return this._o
                            }

                            set o(o: Uint8Array) {
                                this._o = o
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeFloat64(encoded, this._a)
                                encoded = encodeFloat32(encoded, this._b)
                                encoded = encodeInt64(encoded, this._d)
                                encoded = encodeInt32(encoded, this._g)
                                encoded = encodeInt32(encoded, this._c)
                                encoded = encodeUint32(encoded, this._e)
                                encoded = encodeUint64(encoded, this._f)
                                encoded = encodeUint32(encoded, this._i)
                                encoded = encodeUint64(encoded, this._j)
                                encoded = encodeBoolean(encoded, this._m)
                                encoded = encodeInt32(encoded, this._k)
                                encoded = encodeInt64(encoded, this._l)
                                encoded = encodeInt64(encoded, this._h)
                                encoded = encodeString(encoded, this._n)
                                encoded = encodeUint8Array(encoded, this._o)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: ExampleMessage
                                    } {
                                let decoded = buf
                                const aTemp = decodeFloat64(decoded)
                                decoded = aTemp.buf
                                const bTemp = decodeFloat32(decoded)
                                decoded = bTemp.buf
                                const dTemp = decodeInt64(decoded)
                                decoded = dTemp.buf
                                const gTemp = decodeInt32(decoded)
                                decoded = gTemp.buf
                                const cTemp = decodeInt32(decoded)
                                decoded = cTemp.buf
                                const eTemp = decodeUint32(decoded)
                                decoded = eTemp.buf
                                const fTemp = decodeUint64(decoded)
                                decoded = fTemp.buf
                                const iTemp = decodeUint32(decoded)
                                decoded = iTemp.buf
                                const jTemp = decodeUint64(decoded)
                                decoded = jTemp.buf
                                const mTemp = decodeBoolean(decoded)
                                decoded = mTemp.buf
                                const kTemp = decodeInt32(decoded)
                                decoded = kTemp.buf
                                const lTemp = decodeInt64(decoded)
                                decoded = lTemp.buf
                                const hTemp = decodeInt64(decoded)
                                decoded = hTemp.buf
                                const nTemp = decodeString(decoded)
                                decoded = nTemp.buf
                                const oTemp = decodeUint8Array(decoded)
                                decoded = oTemp.buf
                                return {
                                      buf: decoded,
                                      value: new ExampleMessage(aTemp.value,bTemp.value,dTemp.value,gTemp.value,cTemp.value,eTemp.value,fTemp.value,iTemp.value,jTemp.value,mTemp.value,kTemp.value,lTemp.value,hTemp.value,nTemp.value,oTemp.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for edgecases.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeInt64, decodeInt64, encodeBoolean, decodeBoolean, encodeUint8Array, decodeUint8Array, encodeString, decodeString, encodeArray, Kind, encodeMap, decodeArray, decodeMap } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace edgecases {
                        export class ExampleMessage {
                            constructor(a: bigint[], b: boolean[], c: Uint8Array[], d: Map<string, bigint>, e: Map<string, boolean>, f: Map<string, string>, g: Map<string, Uint8Array>) {
                                this._a = a
                                this._b = b
                                this._c = c
                                this._d = d
                                this._e = e
                                this._f = f
                                this._g = g
                            }

                            private _a: bigint[];

                            get a(): bigint[] {
                                return this._a
                            }

                            set a(a: bigint[]) {
                                this._a = a
                            }

                            private _b: boolean[];

                            get b(): boolean[] {
                                return this._b
                            }

                            set b(b: boolean[]) {
                                this._b = b
                            }

                            private _c: Uint8Array[];

                            get c(): Uint8Array[] {
                                return this._c
                            }

                            set c(c: Uint8Array[]) {
                                this._c = c
                            }

                            private _d: Map<string, bigint>;

                            get d(): Map<string, bigint> {
                                return this._d
                            }

                            set d(d: Map<string, bigint>) {
                                this._d = d
                            }

                            private _e: Map<string, boolean>;

                            get e(): Map<string, boolean> {
                                return this._e
                            }

                            set e(e: Map<string, boolean>) {
                                this._e = e
                            }

                            private _f: Map<string, string>;

                            get f(): Map<string, string> {
                                return this._f
                            }

                            set f(f: Map<string, string>) {
                                this._f = f
                            }

                            private _g: Map<string, Uint8Array>;

                            get g(): Map<string, Uint8Array> {
                                return this._g
                            }

                            set g(g: Map<string, Uint8Array>) {
                                this._g = g
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeArray(encoded, this._a.length, Kind.Int64)
                                this._a.forEach(field => {
                                                  encoded = encodeInt64(encoded, field);
                                                })
                                encoded = encodeArray(encoded, this._b.length, Kind.Boolean)
                                this._b.forEach(field => {
                                                  encoded = encodeBoolean(encoded, field);
                                                })
                                encoded = encodeArray(encoded, this._c.length, Kind.Uint8Array)
                                this._c.forEach(field => {
                                                  encoded = encodeUint8Array(encoded, field);
                                                })
                                encoded = encodeMap(encoded, this._d.size,
                                              Kind.String,
                                              Kind.Int64)
                                this._d.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeInt64(encoded, value);
                                                })
                                encoded = encodeMap(encoded, this._e.size,
                                              Kind.String,
                                              Kind.Boolean)
                                this._e.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeBoolean(encoded, value);
                                                })
                                encoded = encodeMap(encoded, this._f.size,
                                              Kind.String,
                                              Kind.String)
                                this._f.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeString(encoded, value);
                                                })
                                encoded = encodeMap(encoded, this._g.size,
                                              Kind.String,
                                              Kind.Uint8Array)
                                this._g.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeUint8Array(encoded, value);
                                                })
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: ExampleMessage
                                    } {
                                let decoded = buf
                                const aArray = decodeArray(decoded)
                                decoded = aArray.buf
                                const aTemp: { value: bigint[] } = {
                                                  value: [],
                                                }

                                for (let i = 0; i < aArray.size; i++) {
                                                  const element = decodeInt64(decoded);
                                                  decoded = element.buf;
                                                  aTemp.value.push(element.value);
                                                }

                                const bArray = decodeArray(decoded)
                                decoded = bArray.buf
                                const bTemp: { value: boolean[] } = {
                                                  value: [],
                                                }

                                for (let i = 0; i < bArray.size; i++) {
                                                  const element = decodeBoolean(decoded);
                                                  decoded = element.buf;
                                                  bTemp.value.push(element.value);
                                                }

                                const cArray = decodeArray(decoded)
                                decoded = cArray.buf
                                const cTemp: { value: Uint8Array[] } = {
                                                  value: [],
                                                }

                                for (let i = 0; i < cArray.size; i++) {
                                                  const element = decodeUint8Array(decoded);
                                                  decoded = element.buf;
                                                  cTemp.value.push(element.value);
                                                }

                                const dMap = decodeMap(decoded)
                                decoded = dMap.buf
                                const d: { value: Map<string, bigint> } = {
                                                  value: new Map<string, bigint>(),
                                                }

                                for (let i = 0; i < dMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeInt64(decoded);
                                                  decoded = value.buf;
                                                  dTemp.value.set(key.value, value.value);
                                                }

                                const eMap = decodeMap(decoded)
                                decoded = eMap.buf
                                const e: { value: Map<string, boolean> } = {
                                                  value: new Map<string, boolean>(),
                                                }

                                for (let i = 0; i < eMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeBoolean(decoded);
                                                  decoded = value.buf;
                                                  eTemp.value.set(key.value, value.value);
                                                }

                                const fMap = decodeMap(decoded)
                                decoded = fMap.buf
                                const f: { value: Map<string, string> } = {
                                                  value: new Map<string, string>(),
                                                }

                                for (let i = 0; i < fMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeString(decoded);
                                                  decoded = value.buf;
                                                  fTemp.value.set(key.value, value.value);
                                                }

                                const gMap = decodeMap(decoded)
                                decoded = gMap.buf
                                const g: { value: Map<string, Uint8Array> } = {
                                                  value: new Map<string, Uint8Array>(),
                                                }

                                for (let i = 0; i < gMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeUint8Array(decoded);
                                                  decoded = value.buf;
                                                  gTemp.value.set(key.value, value.value);
                                                }

                                return {
                                      buf: decoded,
                                      value: new ExampleMessage(aTemp.value,bTemp.value,cTemp.value,dTemp.value,eTemp.value,fTemp.value,gTemp.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for empty.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace empty {
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for empty_options.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace empty {
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for enum.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeUint8, decodeUint8 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace enm {
                        enum MessageType {
                            MESSAGE_TYPE_A = 0,
                            MESSAGE_TYPE_B = 1,
                            MESSAGE_TYPE_C = 2
                        }

                        export class ExampleMessage {
                            constructor(type: MessageType) {
                                this._type = type
                            }

                            private _type: MessageType;

                            get type(): MessageType {
                                return this._type
                            }

                            set type(type: MessageType) {
                                this._type = type
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeUint8(encoded, this._type as number)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: ExampleMessage
                                    } {
                                let decoded = buf
                                const typeUint8 = decodeUint8(decoded)
                                const typeTemp = { value: typeUint8.value as MessageType }

                                decoded = typeUint8.buf
                                return {
                                      buf: decoded,
                                      value: new ExampleMessage(typeTemp.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for http.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString, encodeUint64, decodeUint64, encodeUint8Array, decodeUint8Array, encodeUint32, decodeUint32, encodeMap, Kind, decodeMap } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace http {
                        export class Request {
                            constructor(method: string, url: string, length: bigint, origin: string, protocol: string, ip: string, body: Uint8Array, headers: Map<string, string>, query: Map<string, string>) {
                                this._method = method
                                this._url = url
                                this._length = length
                                this._origin = origin
                                this._protocol = protocol
                                this._ip = ip
                                this._body = body
                                this._headers = headers
                                this._query = query
                            }

                            private _method: string;

                            get method(): string {
                                return this._method
                            }

                            set method(method: string) {
                                this._method = method
                            }

                            private _url: string;

                            get url(): string {
                                return this._url
                            }

                            set url(url: string) {
                                this._url = url
                            }

                            private _length: bigint;

                            get length(): bigint {
                                return this._length
                            }

                            set length(length: bigint) {
                                this._length = length
                            }

                            private _origin: string;

                            get origin(): string {
                                return this._origin
                            }

                            set origin(origin: string) {
                                this._origin = origin
                            }

                            private _protocol: string;

                            get protocol(): string {
                                return this._protocol
                            }

                            set protocol(protocol: string) {
                                this._protocol = protocol
                            }

                            private _ip: string;

                            get ip(): string {
                                return this._ip
                            }

                            set ip(ip: string) {
                                this._ip = ip
                            }

                            private _body: Uint8Array;

                            get body(): Uint8Array {
                                return this._body
                            }

                            set body(body: Uint8Array) {
                                this._body = body
                            }

                            private _headers: Map<string, string>;

                            get headers(): Map<string, string> {
                                return this._headers
                            }

                            set headers(headers: Map<string, string>) {
                                this._headers = headers
                            }

                            private _query: Map<string, string>;

                            get query(): Map<string, string> {
                                return this._query
                            }

                            set query(query: Map<string, string>) {
                                this._query = query
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._method)
                                encoded = encodeString(encoded, this._url)
                                encoded = encodeUint64(encoded, this._length)
                                encoded = encodeString(encoded, this._origin)
                                encoded = encodeString(encoded, this._protocol)
                                encoded = encodeString(encoded, this._ip)
                                encoded = encodeUint8Array(encoded, this._body)
                                encoded = encodeMap(encoded, this._headers.size,
                                              Kind.String,
                                              Kind.String)
                                this._headers.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeString(encoded, value);
                                                })
                                encoded = encodeMap(encoded, this._query.size,
                                              Kind.String,
                                              Kind.String)
                                this._query.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeString(encoded, value);
                                                })
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: Request
                                    } {
                                let decoded = buf
                                const methodTemp = decodeString(decoded)
                                decoded = methodTemp.buf
                                const urlTemp = decodeString(decoded)
                                decoded = urlTemp.buf
                                const lengthTemp = decodeUint64(decoded)
                                decoded = lengthTemp.buf
                                const originTemp = decodeString(decoded)
                                decoded = originTemp.buf
                                const protocolTemp = decodeString(decoded)
                                decoded = protocolTemp.buf
                                const ipTemp = decodeString(decoded)
                                decoded = ipTemp.buf
                                const bodyTemp = decodeUint8Array(decoded)
                                decoded = bodyTemp.buf
                                const headersMap = decodeMap(decoded)
                                decoded = headersMap.buf
                                const headers: { value: Map<string, string> } = {
                                                  value: new Map<string, string>(),
                                                }

                                for (let i = 0; i < headersMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeString(decoded);
                                                  decoded = value.buf;
                                                  headersTemp.value.set(key.value, value.value);
                                                }

                                const queryMap = decodeMap(decoded)
                                decoded = queryMap.buf
                                const query: { value: Map<string, string> } = {
                                                  value: new Map<string, string>(),
                                                }

                                for (let i = 0; i < queryMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeString(decoded);
                                                  decoded = value.buf;
                                                  queryTemp.value.set(key.value, value.value);
                                                }

                                return {
                                      buf: decoded,
                                      value: new Request(methodTemp.value,urlTemp.value,lengthTemp.value,originTemp.value,protocolTemp.value,ipTemp.value,bodyTemp.value,headersTemp.value,queryTemp.value)
                                    }
                            }
                        }

                        export class Response {
                            constructor(status: number, body: Uint8Array, headers: Map<string, string>) {
                                this._status = status
                                this._body = body
                                this._headers = headers
                            }

                            private _status: number;

                            get status(): number {
                                return this._status
                            }

                            set status(status: number) {
                                this._status = status
                            }

                            private _body: Uint8Array;

                            get body(): Uint8Array {
                                return this._body
                            }

                            set body(body: Uint8Array) {
                                this._body = body
                            }

                            private _headers: Map<string, string>;

                            get headers(): Map<string, string> {
                                return this._headers
                            }

                            set headers(headers: Map<string, string>) {
                                this._headers = headers
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeUint32(encoded, this._status)
                                encoded = encodeUint8Array(encoded, this._body)
                                encoded = encodeMap(encoded, this._headers.size,
                                              Kind.String,
                                              Kind.String)
                                this._headers.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeString(encoded, value);
                                                })
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: Response
                                    } {
                                let decoded = buf
                                const statusTemp = decodeUint32(decoded)
                                decoded = statusTemp.buf
                                const bodyTemp = decodeUint8Array(decoded)
                                decoded = bodyTemp.buf
                                const headersMap = decodeMap(decoded)
                                decoded = headersMap.buf
                                const headers: { value: Map<string, string> } = {
                                                  value: new Map<string, string>(),
                                                }

                                for (let i = 0; i < headersMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeString(decoded);
                                                  decoded = value.buf;
                                                  headersTemp.value.set(key.value, value.value);
                                                }

                                return {
                                      buf: decoded,
                                      value: new Response(statusTemp.value,bodyTemp.value,headersTemp.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for map.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt32, decodeInt32, encodeFloat64, decodeFloat64, encodeMap, Kind, decodeMap } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace map {
                        export class ExampleMessage {
                            constructor(name: string, balances: Map<string, number>, backlinks: Map<string, number>) {
                                this._name = name
                                this._balances = balances
                                this._backlinks = backlinks
                            }

                            private _name: string;

                            get name(): string {
                                return this._name
                            }

                            set name(name: string) {
                                this._name = name
                            }

                            private _balances: Map<string, number>;

                            get balances(): Map<string, number> {
                                return this._balances
                            }

                            set balances(balances: Map<string, number>) {
                                this._balances = balances
                            }

                            private _backlinks: Map<string, number>;

                            get backlinks(): Map<string, number> {
                                return this._backlinks
                            }

                            set backlinks(backlinks: Map<string, number>) {
                                this._backlinks = backlinks
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._name)
                                encoded = encodeMap(encoded, this._balances.size,
                                              Kind.String,
                                              Kind.Int32)
                                this._balances.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeInt32(encoded, value);
                                                })
                                encoded = encodeMap(encoded, this._backlinks.size,
                                              Kind.String,
                                              Kind.Float64)
                                this._backlinks.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeFloat64(encoded, value);
                                                })
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: ExampleMessage
                                    } {
                                let decoded = buf
                                const nameTemp = decodeString(decoded)
                                decoded = nameTemp.buf
                                const balancesMap = decodeMap(decoded)
                                decoded = balancesMap.buf
                                const balances: { value: Map<string, number> } = {
                                                  value: new Map<string, number>(),
                                                }

                                for (let i = 0; i < balancesMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeInt32(decoded);
                                                  decoded = value.buf;
                                                  balancesTemp.value.set(key.value, value.value);
                                                }

                                const backlinksMap = decodeMap(decoded)
                                decoded = backlinksMap.buf
                                const backlinks: { value: Map<string, number> } = {
                                                  value: new Map<string, number>(),
                                                }

                                for (let i = 0; i < backlinksMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeFloat64(decoded);
                                                  decoded = value.buf;
                                                  backlinksTemp.value.set(key.value, value.value);
                                                }

                                return {
                                      buf: decoded,
                                      value: new ExampleMessage(nameTemp.value,balancesTemp.value,backlinksTemp.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for map_composite.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt32, decodeInt32, encodeMap, Kind, decodeMap } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace map {
                        export namespace composite {
                            export class ExampleMessage {
                                constructor(name: string, balances: Map<string, number>, backlinks: Map<string, NestedExampleMessage>) {
                                    this._name = name
                                    this._balances = balances
                                    this._backlinks = backlinks
                                }

                                private _name: string;

                                get name(): string {
                                    return this._name
                                }

                                set name(name: string) {
                                    this._name = name
                                }

                                private _balances: Map<string, number>;

                                get balances(): Map<string, number> {
                                    return this._balances
                                }

                                set balances(balances: Map<string, number>) {
                                    this._balances = balances
                                }

                                private _backlinks: Map<string, NestedExampleMessage>;

                                get backlinks(): Map<string, NestedExampleMessage> {
                                    return this._backlinks
                                }

                                set backlinks(backlinks: Map<string, NestedExampleMessage>) {
                                    this._backlinks = backlinks
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeString(encoded, this._name)
                                    encoded = encodeMap(encoded, this._balances.size,
                                                  Kind.String,
                                                  Kind.Int32)
                                    this._balances.forEach((value, key) => {
                                                      encoded = encodeString(encoded, key);
                                                      encoded = encodeInt32(encoded, value);
                                                    })
                                    encoded = encodeMap(encoded, this._backlinks.size,
                                                  Kind.String, Kind.Any)
                                    this._backlinks.forEach((value, key) => {
                                                      encoded = encodeString(encoded, key);
                                                      encoded = value.encode(encoded);
                                                    })
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: ExampleMessage
                                        } {
                                    let decoded = buf
                                    const nameTemp = decodeString(decoded)
                                    decoded = nameTemp.buf
                                    const balancesMap = decodeMap(decoded)
                                    decoded = balancesMap.buf
                                    const balances: { value: Map<string, number> } = {
                                                      value: new Map<string, number>(),
                                                    }

                                    for (let i = 0; i < balancesMap.size; i++) {
                                                      const key = decodeString(decoded);
                                                      decoded = key.buf;
                                                      const value = decodeInt32(decoded);
                                                      decoded = value.buf;
                                                      balancesTemp.value.set(key.value, value.value);
                                                    }

                                    const backlinksMap = decodeMap(decoded)
                                    decoded = backlinksMap.buf
                                    const backlinks: { value: Map<string, NestedExampleMessage> } = {
                                                      value: new Map<string, NestedExampleMessage>(),
                                                    }

                                    for (let i = 0; i < backlinksMap.size; i++) {
                                                      const key = decodeString(decoded);
                                                      decoded = key.buf;
                                                      const value = NestedExampleMessage.decode(decoded);
                                                      decoded = value.buf;
                                                      backlinksTemp.value.set(key.value, value.value);
                                                    }

                                    return {
                                          buf: decoded,
                                          value: new ExampleMessage(nameTemp.value,balancesTemp.value,backlinksTemp.value)
                                        }
                                }
                            }

                            export class NestedExampleMessage {
                                constructor(age: number) {
                                    this._age = age
                                }

                                private _age: number;

                                get age(): number {
                                    return this._age
                                }

                                set age(age: number) {
                                    this._age = age
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeInt32(encoded, this._age)
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: NestedExampleMessage
                                        } {
                                    let decoded = buf
                                    const ageTemp = decodeInt32(decoded)
                                    decoded = ageTemp.buf
                                    return {
                                          buf: decoded,
                                          value: new NestedExampleMessage(ageTemp.value)
                                        }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for map_enum.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt32, decodeInt32, encodeMap, Kind, encodeUint8, decodeMap, decodeUint8 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace map {
                        export namespace enm {
                            enum MessageType {
                                MESSAGE_TYPE_A = 0,
                                MESSAGE_TYPE_B = 1,
                                MESSAGE_TYPE_C = 2
                            }

                            export class ExampleMessage {
                                constructor(name: string, balances: Map<string, number>, backlinks: Map<string, MessageType>) {
                                    this._name = name
                                    this._balances = balances
                                    this._backlinks = backlinks
                                }

                                private _name: string;

                                get name(): string {
                                    return this._name
                                }

                                set name(name: string) {
                                    this._name = name
                                }

                                private _balances: Map<string, number>;

                                get balances(): Map<string, number> {
                                    return this._balances
                                }

                                set balances(balances: Map<string, number>) {
                                    this._balances = balances
                                }

                                private _backlinks: Map<string, MessageType>;

                                get backlinks(): Map<string, MessageType> {
                                    return this._backlinks
                                }

                                set backlinks(backlinks: Map<string, MessageType>) {
                                    this._backlinks = backlinks
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeString(encoded, this._name)
                                    encoded = encodeMap(encoded, this._balances.size,
                                                  Kind.String,
                                                  Kind.Int32)
                                    this._balances.forEach((value, key) => {
                                                      encoded = encodeString(encoded, key);
                                                      encoded = encodeInt32(encoded, value);
                                                    })
                                    encoded = encodeMap(encoded, this._backlinks.size,
                                                  Kind.String, Kind.Any)
                                    this._backlinks.forEach((value, key) => {
                                                      encoded = encodeString(encoded, key);
                                                      encoded = encodeUint8(encoded, value as number);
                                                    })
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: ExampleMessage
                                        } {
                                    let decoded = buf
                                    const nameTemp = decodeString(decoded)
                                    decoded = nameTemp.buf
                                    const balancesMap = decodeMap(decoded)
                                    decoded = balancesMap.buf
                                    const balances: { value: Map<string, number> } = {
                                                      value: new Map<string, number>(),
                                                    }

                                    for (let i = 0; i < balancesMap.size; i++) {
                                                      const key = decodeString(decoded);
                                                      decoded = key.buf;
                                                      const value = decodeInt32(decoded);
                                                      decoded = value.buf;
                                                      balancesTemp.value.set(key.value, value.value);
                                                    }

                                    const backlinksMap = decodeMap(decoded)
                                    decoded = backlinksMap.buf
                                    const backlinks: { value: Map<string, MessageType> } = {
                                                      value: new Map<string, MessageType>(),
                                                    }

                                    for (let i = 0; i < backlinksMap.size; i++) {
                                                      const key = decodeString(decoded);
                                                      decoded = key.buf;
                                                      const value = decodeUint8(decoded);
                                                      decoded = value.buf;
                                                      backlinksTemp.value.set(key.value, value.value as MessageType);
                                                    }

                                    return {
                                          buf: decoded,
                                          value: new ExampleMessage(nameTemp.value,balancesTemp.value,backlinksTemp.value)
                                        }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeInt64, decodeInt64, encodeBoolean, decodeBoolean, encodeInt32, decodeInt32 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export class Outer {
                        constructor(a: OuterMiddleAA, b: OuterMiddleBB) {
                            this._a = a
                            this._b = b
                        }

                        private _a: OuterMiddleAA;

                        get a(): OuterMiddleAA {
                            return this._a
                        }

                        set a(a: OuterMiddleAA) {
                            this._a = a
                        }

                        private _b: OuterMiddleBB;

                        get b(): OuterMiddleBB {
                            return this._b
                        }

                        set b(b: OuterMiddleBB) {
                            this._b = b
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = this._a.encode(encoded)
                            encoded = this._b.encode(encoded)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: Outer
                                } {
                            let decoded = buf
                            const aTemp = OuterMiddleAA.decode(decoded)
                            decoded = aTemp.buf
                            const bTemp = OuterMiddleBB.decode(decoded)
                            decoded = bTemp.buf
                            return {
                                  buf: decoded,
                                  value: new Outer(aTemp.value,bTemp.value)
                                }
                        }
                    }

                    export class OuterMiddleAA {
                        constructor(a: OuterMiddleAAInner) {
                            this._a = a
                        }

                        private _a: OuterMiddleAAInner;

                        get a(): OuterMiddleAAInner {
                            return this._a
                        }

                        set a(a: OuterMiddleAAInner) {
                            this._a = a
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = this._a.encode(encoded)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: OuterMiddleAA
                                } {
                            let decoded = buf
                            const aTemp = OuterMiddleAAInner.decode(decoded)
                            decoded = aTemp.buf
                            return {
                                  buf: decoded,
                                  value: new OuterMiddleAA(aTemp.value)
                                }
                        }
                    }

                    export class OuterMiddleAAInner {
                        constructor(a: bigint, b: boolean) {
                            this._a = a
                            this._b = b
                        }

                        private _a: bigint;

                        get a(): bigint {
                            return this._a
                        }

                        set a(a: bigint) {
                            this._a = a
                        }

                        private _b: boolean;

                        get b(): boolean {
                            return this._b
                        }

                        set b(b: boolean) {
                            this._b = b
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeInt64(encoded, this._a)
                            encoded = encodeBoolean(encoded, this._b)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: OuterMiddleAAInner
                                } {
                            let decoded = buf
                            const aTemp = decodeInt64(decoded)
                            decoded = aTemp.buf
                            const bTemp = decodeBoolean(decoded)
                            decoded = bTemp.buf
                            return {
                                  buf: decoded,
                                  value: new OuterMiddleAAInner(aTemp.value,bTemp.value)
                                }
                        }
                    }

                    export class OuterMiddleBB {
                        constructor(a: OuterMiddleBBInner) {
                            this._a = a
                        }

                        private _a: OuterMiddleBBInner;

                        get a(): OuterMiddleBBInner {
                            return this._a
                        }

                        set a(a: OuterMiddleBBInner) {
                            this._a = a
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = this._a.encode(encoded)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: OuterMiddleBB
                                } {
                            let decoded = buf
                            const aTemp = OuterMiddleBBInner.decode(decoded)
                            decoded = aTemp.buf
                            return {
                                  buf: decoded,
                                  value: new OuterMiddleBB(aTemp.value)
                                }
                        }
                    }

                    export class OuterMiddleBBInner {
                        constructor(a: number, b: boolean) {
                            this._a = a
                            this._b = b
                        }

                        private _a: number;

                        get a(): number {
                            return this._a
                        }

                        set a(a: number) {
                            this._a = a
                        }

                        private _b: boolean;

                        get b(): boolean {
                            return this._b
                        }

                        set b(b: boolean) {
                            this._b = b
                        }

                        encode(buf: Uint8Array): Uint8Array {
                            let encoded = buf
                            encoded = encodeInt32(encoded, this._a)
                            encoded = encodeBoolean(encoded, this._b)
                            return encoded
                        }

                        static decode(buf: Uint8Array): {
                                  buf: Uint8Array,
                                  value: OuterMiddleBBInner
                                } {
                            let decoded = buf
                            const aTemp = decodeInt32(decoded)
                            decoded = aTemp.buf
                            const bTemp = decodeBoolean(decoded)
                            decoded = bTemp.buf
                            return {
                                  buf: decoded,
                                  value: new OuterMiddleBBInner(aTemp.value,bTemp.value)
                                }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_array.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeInt64, decodeInt64, encodeBoolean, decodeBoolean, encodeInt32, decodeInt32, encodeArray, Kind, decodeArray } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace array {
                        export class Outer {
                            constructor(b: OuterMiddleBB[], a: OuterMiddleAA) {
                                this._b = b
                                this._a = a
                            }

                            private _b: OuterMiddleBB[];

                            get b(): OuterMiddleBB[] {
                                return this._b
                            }

                            set b(b: OuterMiddleBB[]) {
                                this._b = b
                            }

                            private _a: OuterMiddleAA;

                            get a(): OuterMiddleAA {
                                return this._a
                            }

                            set a(a: OuterMiddleAA) {
                                this._a = a
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeArray(encoded, this._b.length, Kind.Any)
                                this._b.forEach((field) => {
                                                  encoded = field.encode(encoded);
                                                })
                                encoded = this._a.encode(encoded)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: Outer
                                    } {
                                let decoded = buf
                                const bArray = decodeArray(decoded)
                                decoded = bArray.buf
                                const bTemp: { value: OuterMiddleBB[] } = {
                                                  value: [],
                                                }

                                for (let i = 0; i < bArray.size; i++) {
                                                  const element = OuterMiddleBB.decode(decoded);
                                                  decoded = element.buf;
                                                  bTemp.value.push(element.value);
                                                }

                                const aTemp = OuterMiddleAA.decode(decoded)
                                decoded = aTemp.buf
                                return {
                                      buf: decoded,
                                      value: new Outer(bTemp.value,aTemp.value)
                                    }
                            }
                        }

                        export class OuterMiddleAA {
                            constructor(a: OuterMiddleAAInner[]) {
                                this._a = a
                            }

                            private _a: OuterMiddleAAInner[];

                            get a(): OuterMiddleAAInner[] {
                                return this._a
                            }

                            set a(a: OuterMiddleAAInner[]) {
                                this._a = a
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeArray(encoded, this._a.length, Kind.Any)
                                this._a.forEach((field) => {
                                                  encoded = field.encode(encoded);
                                                })
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleAA
                                    } {
                                let decoded = buf
                                const aArray = decodeArray(decoded)
                                decoded = aArray.buf
                                const aTemp: { value: OuterMiddleAAInner[] } = {
                                                  value: [],
                                                }

                                for (let i = 0; i < aArray.size; i++) {
                                                  const element = OuterMiddleAAInner.decode(decoded);
                                                  decoded = element.buf;
                                                  aTemp.value.push(element.value);
                                                }

                                return {
                                      buf: decoded,
                                      value: new OuterMiddleAA(aTemp.value)
                                    }
                            }
                        }

                        export class OuterMiddleAAInner {
                            constructor(a: bigint, b: boolean) {
                                this._a = a
                                this._b = b
                            }

                            private _a: bigint;

                            get a(): bigint {
                                return this._a
                            }

                            set a(a: bigint) {
                                this._a = a
                            }

                            private _b: boolean;

                            get b(): boolean {
                                return this._b
                            }

                            set b(b: boolean) {
                                this._b = b
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeInt64(encoded, this._a)
                                encoded = encodeBoolean(encoded, this._b)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleAAInner
                                    } {
                                let decoded = buf
                                const aTemp = decodeInt64(decoded)
                                decoded = aTemp.buf
                                const bTemp = decodeBoolean(decoded)
                                decoded = bTemp.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleAAInner(aTemp.value,bTemp.value)
                                    }
                            }
                        }

                        export class OuterMiddleBB {
                            constructor(a: OuterMiddleBBInner) {
                                this._a = a
                            }

                            private _a: OuterMiddleBBInner;

                            get a(): OuterMiddleBBInner {
                                return this._a
                            }

                            set a(a: OuterMiddleBBInner) {
                                this._a = a
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = this._a.encode(encoded)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleBB
                                    } {
                                let decoded = buf
                                const aTemp = OuterMiddleBBInner.decode(decoded)
                                decoded = aTemp.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleBB(aTemp.value)
                                    }
                            }
                        }

                        export class OuterMiddleBBInner {
                            constructor(a: number, b: boolean) {
                                this._a = a
                                this._b = b
                            }

                            private _a: number;

                            get a(): number {
                                return this._a
                            }

                            set a(a: number) {
                                this._a = a
                            }

                            private _b: boolean;

                            get b(): boolean {
                                return this._b
                            }

                            set b(b: boolean) {
                                this._b = b
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeInt32(encoded, this._a)
                                encoded = encodeBoolean(encoded, this._b)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleBBInner
                                    } {
                                let decoded = buf
                                const aTemp = decodeInt32(decoded)
                                decoded = aTemp.buf
                                const bTemp = decodeBoolean(decoded)
                                decoded = bTemp.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleBBInner(aTemp.value,bTemp.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_enum.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString, encodeUint8, decodeUint8 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace enm {
                        enum RequestCorpus {
                            UNIVERSAL = 0,
                            WEB = 1,
                            IMAGES = 2,
                            LOCAL = 3,
                            NEWS = 4,
                            PRODUCTS = 5,
                            VIDEO = 6
                        }

                        export class Request {
                            constructor(Message: string, corpus: RequestCorpus) {
                                this._Message = Message
                                this._corpus = corpus
                            }

                            private _Message: string;

                            get Message(): string {
                                return this._Message
                            }

                            set Message(Message: string) {
                                this._Message = Message
                            }

                            private _corpus: RequestCorpus;

                            get corpus(): RequestCorpus {
                                return this._corpus
                            }

                            set corpus(corpus: RequestCorpus) {
                                this._corpus = corpus
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._Message)
                                encoded = encodeUint8(encoded, this._corpus as number)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: Request
                                    } {
                                let decoded = buf
                                const MessageTemp = decodeString(decoded)
                                decoded = MessageTemp.buf
                                const corpusUint8 = decodeUint8(decoded)
                                const corpusTemp = { value: corpusUint8.value as RequestCorpus }

                                decoded = corpusUint8.buf
                                return {
                                      buf: decoded,
                                      value: new Request(MessageTemp.value,corpusTemp.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_enum_array.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString, encodeUint8, encodeArray, Kind, decodeUint8, decodeArray } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace enm {
                        export namespace array {
                            enum RequestCorpus {
                                UNIVERSAL = 0,
                                WEB = 1,
                                IMAGES = 2,
                                LOCAL = 3,
                                NEWS = 4,
                                PRODUCTS = 5,
                                VIDEO = 6
                            }

                            export class Request {
                                constructor(Message: string, corpus: RequestCorpus[]) {
                                    this._Message = Message
                                    this._corpus = corpus
                                }

                                private _Message: string;

                                get Message(): string {
                                    return this._Message
                                }

                                set Message(Message: string) {
                                    this._Message = Message
                                }

                                private _corpus: RequestCorpus[];

                                get corpus(): RequestCorpus[] {
                                    return this._corpus
                                }

                                set corpus(corpus: RequestCorpus[]) {
                                    this._corpus = corpus
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeString(encoded, this._Message)
                                    encoded = encodeArray(encoded, this._corpus.length, Kind.Any)
                                    this._corpus.forEach(field => {
                                                      encoded = encodeUint8(encoded, field as number);
                                                    })
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: Request
                                        } {
                                    let decoded = buf
                                    const MessageTemp = decodeString(decoded)
                                    decoded = MessageTemp.buf
                                    const corpusArray = decodeArray(decoded)
                                    decoded = corpusArray.buf
                                    const corpusTemp: { value: RequestCorpus[] } = {
                                                      value: [],
                                                    }

                                    for (let i = 0; i < corpusArray.size; i++) {
                                                      const element = decodeUint8(decoded);
                                                      decoded = element.buf;
                                                      corpusTemp.value.push(element.value as RequestCorpus);
                                                    }

                                    return {
                                          buf: decoded,
                                          value: new Request(MessageTemp.value,corpusTemp.value)
                                        }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_enum_deeper.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString, encodeUint8, decodeUint8 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace enm {
                        enum RequestNestedRequestCorpus {
                            UNIVERSAL = 0,
                            WEB = 1,
                            IMAGES = 2,
                            LOCAL = 3,
                            NEWS = 4,
                            PRODUCTS = 5,
                            VIDEO = 6
                        }

                        export class Request {
                            constructor(Message: string, corpus: RequestNestedRequestCorpus) {
                                this._Message = Message
                                this._corpus = corpus
                            }

                            private _Message: string;

                            get Message(): string {
                                return this._Message
                            }

                            set Message(Message: string) {
                                this._Message = Message
                            }

                            private _corpus: RequestNestedRequestCorpus;

                            get corpus(): RequestNestedRequestCorpus {
                                return this._corpus
                            }

                            set corpus(corpus: RequestNestedRequestCorpus) {
                                this._corpus = corpus
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._Message)
                                encoded = encodeUint8(encoded, this._corpus as number)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: Request
                                    } {
                                let decoded = buf
                                const MessageTemp = decodeString(decoded)
                                decoded = MessageTemp.buf
                                const corpusUint8 = decodeUint8(decoded)
                                const corpusTemp = { value: corpusUint8.value as RequestNestedRequestCorpus }

                                decoded = corpusUint8.buf
                                return {
                                      buf: decoded,
                                      value: new Request(MessageTemp.value,corpusTemp.value)
                                    }
                            }
                        }

                        export class RequestNestedRequest {
                            constructor() {
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: RequestNestedRequest
                                    } {
                                let decoded = buf
                                return {
                                      buf: decoded,
                                      value: new RequestNestedRequest()
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_enum_map.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString, encodeUint8, encodeMap, Kind, decodeUint8, decodeMap } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace enm {
                        export namespace map {
                            enum RequestCorpus {
                                UNIVERSAL = 0,
                                WEB = 1,
                                IMAGES = 2,
                                LOCAL = 3,
                                NEWS = 4,
                                PRODUCTS = 5,
                                VIDEO = 6
                            }

                            export class Request {
                                constructor(Message: string, corpus: Map<string, RequestCorpus>) {
                                    this._Message = Message
                                    this._corpus = corpus
                                }

                                private _Message: string;

                                get Message(): string {
                                    return this._Message
                                }

                                set Message(Message: string) {
                                    this._Message = Message
                                }

                                private _corpus: Map<string, RequestCorpus>;

                                get corpus(): Map<string, RequestCorpus> {
                                    return this._corpus
                                }

                                set corpus(corpus: Map<string, RequestCorpus>) {
                                    this._corpus = corpus
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeString(encoded, this._Message)
                                    encoded = encodeMap(encoded, this._corpus.size,
                                                  Kind.String, Kind.Any)
                                    this._corpus.forEach((value, key) => {
                                                      encoded = encodeString(encoded, key);
                                                      encoded = encodeUint8(encoded, value as number);
                                                    })
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: Request
                                        } {
                                    let decoded = buf
                                    const MessageTemp = decodeString(decoded)
                                    decoded = MessageTemp.buf
                                    const corpusMap = decodeMap(decoded)
                                    decoded = corpusMap.buf
                                    const corpus: { value: Map<string, RequestCorpus> } = {
                                                      value: new Map<string, RequestCorpus>(),
                                                    }

                                    for (let i = 0; i < corpusMap.size; i++) {
                                                      const key = decodeString(decoded);
                                                      decoded = key.buf;
                                                      const value = decodeUint8(decoded);
                                                      decoded = value.buf;
                                                      corpusTemp.value.set(key.value, value.value as RequestCorpus);
                                                    }

                                    return {
                                          buf: decoded,
                                          value: new Request(MessageTemp.value,corpusTemp.value)
                                        }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_enum_reference.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeInt64, decodeInt64, encodeBoolean, decodeBoolean, encodeInt32, decodeInt32, encodeUint8, decodeUint8 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace enm {
                        export namespace reference {
                            enum OuterMiddleBBCorpus {
                                UNIVERSAL = 0,
                                WEB = 1,
                                IMAGES = 2,
                                LOCAL = 3,
                                NEWS = 4,
                                PRODUCTS = 5,
                                VIDEO = 6
                            }

                            export class Outer {
                                constructor(c: OuterMiddleBBCorpus, a: OuterMiddleAA, b: OuterMiddleBBInner) {
                                    this._c = c
                                    this._a = a
                                    this._b = b
                                }

                                private _c: OuterMiddleBBCorpus;

                                get c(): OuterMiddleBBCorpus {
                                    return this._c
                                }

                                set c(c: OuterMiddleBBCorpus) {
                                    this._c = c
                                }

                                private _a: OuterMiddleAA;

                                get a(): OuterMiddleAA {
                                    return this._a
                                }

                                set a(a: OuterMiddleAA) {
                                    this._a = a
                                }

                                private _b: OuterMiddleBBInner;

                                get b(): OuterMiddleBBInner {
                                    return this._b
                                }

                                set b(b: OuterMiddleBBInner) {
                                    this._b = b
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeUint8(encoded, this._c as number)
                                    encoded = this._a.encode(encoded)
                                    encoded = this._b.encode(encoded)
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: Outer
                                        } {
                                    let decoded = buf
                                    const cUint8 = decodeUint8(decoded)
                                    const cTemp = { value: cUint8.value as OuterMiddleBBCorpus }

                                    decoded = cUint8.buf
                                    const aTemp = OuterMiddleAA.decode(decoded)
                                    decoded = aTemp.buf
                                    const bTemp = OuterMiddleBBInner.decode(decoded)
                                    decoded = bTemp.buf
                                    return {
                                          buf: decoded,
                                          value: new Outer(cTemp.value,aTemp.value,bTemp.value)
                                        }
                                }
                            }

                            export class OuterMiddleAA {
                                constructor(a: OuterMiddleAAInner) {
                                    this._a = a
                                }

                                private _a: OuterMiddleAAInner;

                                get a(): OuterMiddleAAInner {
                                    return this._a
                                }

                                set a(a: OuterMiddleAAInner) {
                                    this._a = a
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = this._a.encode(encoded)
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: OuterMiddleAA
                                        } {
                                    let decoded = buf
                                    const aTemp = OuterMiddleAAInner.decode(decoded)
                                    decoded = aTemp.buf
                                    return {
                                          buf: decoded,
                                          value: new OuterMiddleAA(aTemp.value)
                                        }
                                }
                            }

                            export class OuterMiddleAAInner {
                                constructor(a: bigint, b: boolean) {
                                    this._a = a
                                    this._b = b
                                }

                                private _a: bigint;

                                get a(): bigint {
                                    return this._a
                                }

                                set a(a: bigint) {
                                    this._a = a
                                }

                                private _b: boolean;

                                get b(): boolean {
                                    return this._b
                                }

                                set b(b: boolean) {
                                    this._b = b
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeInt64(encoded, this._a)
                                    encoded = encodeBoolean(encoded, this._b)
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: OuterMiddleAAInner
                                        } {
                                    let decoded = buf
                                    const aTemp = decodeInt64(decoded)
                                    decoded = aTemp.buf
                                    const bTemp = decodeBoolean(decoded)
                                    decoded = bTemp.buf
                                    return {
                                          buf: decoded,
                                          value: new OuterMiddleAAInner(aTemp.value,bTemp.value)
                                        }
                                }
                            }

                            export class OuterMiddleBB {
                                constructor(a: OuterMiddleBBInner) {
                                    this._a = a
                                }

                                private _a: OuterMiddleBBInner;

                                get a(): OuterMiddleBBInner {
                                    return this._a
                                }

                                set a(a: OuterMiddleBBInner) {
                                    this._a = a
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = this._a.encode(encoded)
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: OuterMiddleBB
                                        } {
                                    let decoded = buf
                                    const aTemp = OuterMiddleBBInner.decode(decoded)
                                    decoded = aTemp.buf
                                    return {
                                          buf: decoded,
                                          value: new OuterMiddleBB(aTemp.value)
                                        }
                                }
                            }

                            export class OuterMiddleBBInner {
                                constructor(a: number, b: boolean) {
                                    this._a = a
                                    this._b = b
                                }

                                private _a: number;

                                get a(): number {
                                    return this._a
                                }

                                set a(a: number) {
                                    this._a = a
                                }

                                private _b: boolean;

                                get b(): boolean {
                                    return this._b
                                }

                                set b(b: boolean) {
                                    this._b = b
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeInt32(encoded, this._a)
                                    encoded = encodeBoolean(encoded, this._b)
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: OuterMiddleBBInner
                                        } {
                                    let decoded = buf
                                    const aTemp = decodeInt32(decoded)
                                    decoded = aTemp.buf
                                    const bTemp = decodeBoolean(decoded)
                                    decoded = bTemp.buf
                                    return {
                                          buf: decoded,
                                          value: new OuterMiddleBBInner(aTemp.value,bTemp.value)
                                        }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_map.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt64, decodeInt64, encodeBoolean, decodeBoolean, encodeInt32, decodeInt32, encodeMap, Kind, decodeMap } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace array {
                        export class Outer {
                            constructor(a: OuterMiddleAA, b: Map<string, OuterMiddleBB>) {
                                this._a = a
                                this._b = b
                            }

                            private _a: OuterMiddleAA;

                            get a(): OuterMiddleAA {
                                return this._a
                            }

                            set a(a: OuterMiddleAA) {
                                this._a = a
                            }

                            private _b: Map<string, OuterMiddleBB>;

                            get b(): Map<string, OuterMiddleBB> {
                                return this._b
                            }

                            set b(b: Map<string, OuterMiddleBB>) {
                                this._b = b
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = this._a.encode(encoded)
                                encoded = encodeMap(encoded, this._b.size,
                                              Kind.String, Kind.Any)
                                this._b.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = value.encode(encoded);
                                                })
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: Outer
                                    } {
                                let decoded = buf
                                const aTemp = OuterMiddleAA.decode(decoded)
                                decoded = aTemp.buf
                                const bMap = decodeMap(decoded)
                                decoded = bMap.buf
                                const b: { value: Map<string, OuterMiddleBB> } = {
                                                  value: new Map<string, OuterMiddleBB>(),
                                                }

                                for (let i = 0; i < bMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = OuterMiddleBB.decode(decoded);
                                                  decoded = value.buf;
                                                  bTemp.value.set(key.value, value.value);
                                                }

                                return {
                                      buf: decoded,
                                      value: new Outer(aTemp.value,bTemp.value)
                                    }
                            }
                        }

                        export class OuterMiddleAA {
                            constructor(a: OuterMiddleAAInner) {
                                this._a = a
                            }

                            private _a: OuterMiddleAAInner;

                            get a(): OuterMiddleAAInner {
                                return this._a
                            }

                            set a(a: OuterMiddleAAInner) {
                                this._a = a
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = this._a.encode(encoded)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleAA
                                    } {
                                let decoded = buf
                                const aTemp = OuterMiddleAAInner.decode(decoded)
                                decoded = aTemp.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleAA(aTemp.value)
                                    }
                            }
                        }

                        export class OuterMiddleAAInner {
                            constructor(a: bigint, b: boolean) {
                                this._a = a
                                this._b = b
                            }

                            private _a: bigint;

                            get a(): bigint {
                                return this._a
                            }

                            set a(a: bigint) {
                                this._a = a
                            }

                            private _b: boolean;

                            get b(): boolean {
                                return this._b
                            }

                            set b(b: boolean) {
                                this._b = b
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeInt64(encoded, this._a)
                                encoded = encodeBoolean(encoded, this._b)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleAAInner
                                    } {
                                let decoded = buf
                                const aTemp = decodeInt64(decoded)
                                decoded = aTemp.buf
                                const bTemp = decodeBoolean(decoded)
                                decoded = bTemp.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleAAInner(aTemp.value,bTemp.value)
                                    }
                            }
                        }

                        export class OuterMiddleBB {
                            constructor(a: OuterMiddleBBInner) {
                                this._a = a
                            }

                            private _a: OuterMiddleBBInner;

                            get a(): OuterMiddleBBInner {
                                return this._a
                            }

                            set a(a: OuterMiddleBBInner) {
                                this._a = a
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = this._a.encode(encoded)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleBB
                                    } {
                                let decoded = buf
                                const aTemp = OuterMiddleBBInner.decode(decoded)
                                decoded = aTemp.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleBB(aTemp.value)
                                    }
                            }
                        }

                        export class OuterMiddleBBInner {
                            constructor(a: number, b: boolean) {
                                this._a = a
                                this._b = b
                            }

                            private _a: number;

                            get a(): number {
                                return this._a
                            }

                            set a(a: number) {
                                this._a = a
                            }

                            private _b: boolean;

                            get b(): boolean {
                                return this._b
                            }

                            set b(b: boolean) {
                                this._b = b
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeInt32(encoded, this._a)
                                encoded = encodeBoolean(encoded, this._b)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleBBInner
                                    } {
                                let decoded = buf
                                const aTemp = decodeInt32(decoded)
                                decoded = aTemp.buf
                                const bTemp = decodeBoolean(decoded)
                                decoded = bTemp.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleBBInner(aTemp.value,bTemp.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_reference.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeInt64, decodeInt64, encodeBoolean, decodeBoolean, encodeInt32, decodeInt32 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace reference {
                        export class Outer {
                            constructor(a: OuterMiddleAA, b: OuterMiddleBBInner) {
                                this._a = a
                                this._b = b
                            }

                            private _a: OuterMiddleAA;

                            get a(): OuterMiddleAA {
                                return this._a
                            }

                            set a(a: OuterMiddleAA) {
                                this._a = a
                            }

                            private _b: OuterMiddleBBInner;

                            get b(): OuterMiddleBBInner {
                                return this._b
                            }

                            set b(b: OuterMiddleBBInner) {
                                this._b = b
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = this._a.encode(encoded)
                                encoded = this._b.encode(encoded)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: Outer
                                    } {
                                let decoded = buf
                                const aTemp = OuterMiddleAA.decode(decoded)
                                decoded = aTemp.buf
                                const bTemp = OuterMiddleBBInner.decode(decoded)
                                decoded = bTemp.buf
                                return {
                                      buf: decoded,
                                      value: new Outer(aTemp.value,bTemp.value)
                                    }
                            }
                        }

                        export class OuterMiddleAA {
                            constructor(a: OuterMiddleAAInner) {
                                this._a = a
                            }

                            private _a: OuterMiddleAAInner;

                            get a(): OuterMiddleAAInner {
                                return this._a
                            }

                            set a(a: OuterMiddleAAInner) {
                                this._a = a
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = this._a.encode(encoded)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleAA
                                    } {
                                let decoded = buf
                                const aTemp = OuterMiddleAAInner.decode(decoded)
                                decoded = aTemp.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleAA(aTemp.value)
                                    }
                            }
                        }

                        export class OuterMiddleAAInner {
                            constructor(a: bigint, b: boolean) {
                                this._a = a
                                this._b = b
                            }

                            private _a: bigint;

                            get a(): bigint {
                                return this._a
                            }

                            set a(a: bigint) {
                                this._a = a
                            }

                            private _b: boolean;

                            get b(): boolean {
                                return this._b
                            }

                            set b(b: boolean) {
                                this._b = b
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeInt64(encoded, this._a)
                                encoded = encodeBoolean(encoded, this._b)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleAAInner
                                    } {
                                let decoded = buf
                                const aTemp = decodeInt64(decoded)
                                decoded = aTemp.buf
                                const bTemp = decodeBoolean(decoded)
                                decoded = bTemp.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleAAInner(aTemp.value,bTemp.value)
                                    }
                            }
                        }

                        export class OuterMiddleBB {
                            constructor(a: OuterMiddleBBInner) {
                                this._a = a
                            }

                            private _a: OuterMiddleBBInner;

                            get a(): OuterMiddleBBInner {
                                return this._a
                            }

                            set a(a: OuterMiddleBBInner) {
                                this._a = a
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = this._a.encode(encoded)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleBB
                                    } {
                                let decoded = buf
                                const aTemp = OuterMiddleBBInner.decode(decoded)
                                decoded = aTemp.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleBB(aTemp.value)
                                    }
                            }
                        }

                        export class OuterMiddleBBInner {
                            constructor(a: number, b: boolean) {
                                this._a = a
                                this._b = b
                            }

                            private _a: number;

                            get a(): number {
                                return this._a
                            }

                            set a(a: number) {
                                this._a = a
                            }

                            private _b: boolean;

                            get b(): boolean {
                                return this._b
                            }

                            set b(b: boolean) {
                                this._b = b
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeInt32(encoded, this._a)
                                encoded = encodeBoolean(encoded, this._b)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: OuterMiddleBBInner
                                    } {
                                let decoded = buf
                                const aTemp = decodeInt32(decoded)
                                decoded = aTemp.buf
                                const bTemp = decodeBoolean(decoded)
                                decoded = bTemp.buf
                                return {
                                      buf: decoded,
                                      value: new OuterMiddleBBInner(aTemp.value,bTemp.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_reference_outside.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace reference {
                        export namespace outside {
                            export class Second {
                                constructor(a: OuterInner) {
                                    this._a = a
                                }

                                private _a: OuterInner;

                                get a(): OuterInner {
                                    return this._a
                                }

                                set a(a: OuterInner) {
                                    this._a = a
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = this._a.encode(encoded)
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: Second
                                        } {
                                    let decoded = buf
                                    const aTemp = OuterInner.decode(decoded)
                                    decoded = aTemp.buf
                                    return {
                                          buf: decoded,
                                          value: new Second(aTemp.value)
                                        }
                                }
                            }

                            export class Outer {
                                constructor() {
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: Outer
                                        } {
                                    let decoded = buf
                                    return {
                                          buf: decoded,
                                          value: new Outer()
                                        }
                                }
                            }

                            export class OuterInner {
                                constructor(a: string) {
                                    this._a = a
                                }

                                private _a: string;

                                get a(): string {
                                    return this._a
                                }

                                set a(a: string) {
                                    this._a = a
                                }

                                encode(buf: Uint8Array): Uint8Array {
                                    let encoded = buf
                                    encoded = encodeString(encoded, this._a)
                                    return encoded
                                }

                                static decode(buf: Uint8Array): {
                                          buf: Uint8Array,
                                          value: OuterInner
                                        } {
                                    let decoded = buf
                                    const aTemp = decodeString(decoded)
                                    decoded = aTemp.buf
                                    return {
                                          buf: decoded,
                                          value: new OuterInner(aTemp.value)
                                        }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_reference_outside_enum.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeUint8, decodeUint8 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace reference {
                        export namespace outside {
                            export namespace enm {
                                enum OuterCorpus {
                                    UNIVERSAL = 0,
                                    WEB = 1,
                                    IMAGES = 2,
                                    LOCAL = 3,
                                    NEWS = 4,
                                    PRODUCTS = 5,
                                    VIDEO = 6
                                }

                                export class Second {
                                    constructor(a: OuterCorpus) {
                                        this._a = a
                                    }

                                    private _a: OuterCorpus;

                                    get a(): OuterCorpus {
                                        return this._a
                                    }

                                    set a(a: OuterCorpus) {
                                        this._a = a
                                    }

                                    encode(buf: Uint8Array): Uint8Array {
                                        let encoded = buf
                                        encoded = encodeUint8(encoded, this._a as number)
                                        return encoded
                                    }

                                    static decode(buf: Uint8Array): {
                                              buf: Uint8Array,
                                              value: Second
                                            } {
                                        let decoded = buf
                                        const aUint8 = decodeUint8(decoded)
                                        const aTemp = { value: aUint8.value as OuterCorpus }

                                        decoded = aUint8.buf
                                        return {
                                              buf: decoded,
                                              value: new Second(aTemp.value)
                                            }
                                    }
                                }

                                export class Outer {
                                    constructor() {
                                    }

                                    encode(buf: Uint8Array): Uint8Array {
                                        let encoded = buf
                                        return encoded
                                    }

                                    static decode(buf: Uint8Array): {
                                              buf: Uint8Array,
                                              value: Outer
                                            } {
                                        let decoded = buf
                                        return {
                                              buf: decoded,
                                              value: new Outer()
                                            }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nested_reference_outside_hoisted.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace reference {
                        export namespace outside {
                            export namespace hoisted {
                                export class Outer {
                                    constructor() {
                                    }

                                    encode(buf: Uint8Array): Uint8Array {
                                        let encoded = buf
                                        return encoded
                                    }

                                    static decode(buf: Uint8Array): {
                                              buf: Uint8Array,
                                              value: Outer
                                            } {
                                        let decoded = buf
                                        return {
                                              buf: decoded,
                                              value: new Outer()
                                            }
                                    }
                                }

                                export class OuterInner {
                                    constructor(a: string) {
                                        this._a = a
                                    }

                                    private _a: string;

                                    get a(): string {
                                        return this._a
                                    }

                                    set a(a: string) {
                                        this._a = a
                                    }

                                    encode(buf: Uint8Array): Uint8Array {
                                        let encoded = buf
                                        encoded = encodeString(encoded, this._a)
                                        return encoded
                                    }

                                    static decode(buf: Uint8Array): {
                                              buf: Uint8Array,
                                              value: OuterInner
                                            } {
                                        let decoded = buf
                                        const aTemp = decodeString(decoded)
                                        decoded = aTemp.buf
                                        return {
                                              buf: decoded,
                                              value: new OuterInner(aTemp.value)
                                            }
                                    }
                                }

                                export class Second {
                                    constructor(a: OuterInner) {
                                        this._a = a
                                    }

                                    private _a: OuterInner;

                                    get a(): OuterInner {
                                        return this._a
                                    }

                                    set a(a: OuterInner) {
                                        this._a = a
                                    }

                                    encode(buf: Uint8Array): Uint8Array {
                                        let encoded = buf
                                        encoded = this._a.encode(encoded)
                                        return encoded
                                    }

                                    static decode(buf: Uint8Array): {
                                              buf: Uint8Array,
                                              value: Second
                                            } {
                                        let decoded = buf
                                        const aTemp = OuterInner.decode(decoded)
                                        decoded = aTemp.buf
                                        return {
                                              buf: decoded,
                                              value: new Second(aTemp.value)
                                            }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for nopackage.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt32, decodeInt32 } from \\"polyglot-ts\\";

export class User {
    constructor(name: string, age: number, department: Department) {
        this._name = name
        this._age = age
        this._department = department
    }

    private _name: string;

    get name(): string {
        return this._name
    }

    set name(name: string) {
        this._name = name
    }

    private _age: number;

    get age(): number {
        return this._age
    }

    set age(age: number) {
        this._age = age
    }

    private _department: Department;

    get department(): Department {
        return this._department
    }

    set department(department: Department) {
        this._department = department
    }

    encode(buf: Uint8Array): Uint8Array {
        let encoded = buf
        encoded = encodeString(encoded, this._name)
        encoded = encodeInt32(encoded, this._age)
        encoded = this._department.encode(encoded)
        return encoded
    }

    static decode(buf: Uint8Array): {
              buf: Uint8Array,
              value: User
            } {
        let decoded = buf
        const nameTemp = decodeString(decoded)
        decoded = nameTemp.buf
        const ageTemp = decodeInt32(decoded)
        decoded = ageTemp.buf
        const departmentTemp = Department.decode(decoded)
        decoded = departmentTemp.buf
        return {
              buf: decoded,
              value: new User(nameTemp.value,ageTemp.value,departmentTemp.value)
            }
    }
}

export class Department {
    constructor(name: string) {
        this._name = name
    }

    private _name: string;

    get name(): string {
        return this._name
    }

    set name(name: string) {
        this._name = name
    }

    encode(buf: Uint8Array): Uint8Array {
        let encoded = buf
        encoded = encodeString(encoded, this._name)
        return encoded
    }

    static decode(buf: Uint8Array): {
              buf: Uint8Array,
              value: Department
            } {
        let decoded = buf
        const nameTemp = decodeString(decoded)
        decoded = nameTemp.buf
        return {
              buf: decoded,
              value: new Department(nameTemp.value)
            }
    }
}
"
`;

exports[`Generator Can generate TypeScript for oneof.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace oneof {
                        export class SampleMessage {
                            constructor(name: string, potato: string) {
                                this._name = name
                                this._potato = potato
                            }

                            private _name: string;

                            get name(): string {
                                return this._name
                            }

                            set name(name: string) {
                                this._name = name
                            }

                            private _potato: string;

                            get potato(): string {
                                return this._potato
                            }

                            set potato(potato: string) {
                                this._potato = potato
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._name)
                                encoded = encodeString(encoded, this._potato)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: SampleMessage
                                    } {
                                let decoded = buf
                                const nameTemp = decodeString(decoded)
                                decoded = nameTemp.buf
                                const potatoTemp = decodeString(decoded)
                                decoded = potatoTemp.buf
                                return {
                                      buf: decoded,
                                      value: new SampleMessage(nameTemp.value,potatoTemp.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for order.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString, encodeUint8, encodeArray, Kind, encodeMap, decodeUint8, decodeArray, decodeMap } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace order {
                        enum MessageType {
                            MESSAGE_TYPE_A = 0,
                            MESSAGE_TYPE_B = 1,
                            MESSAGE_TYPE_C = 2
                        }

                        export class ExampleMessage {
                            constructor(a: string, b: MessageType, c: string[], e: SecondExampleMessage, d: Map<string, string>) {
                                this._a = a
                                this._b = b
                                this._c = c
                                this._e = e
                                this._d = d
                            }

                            private _a: string;

                            get a(): string {
                                return this._a
                            }

                            set a(a: string) {
                                this._a = a
                            }

                            private _b: MessageType;

                            get b(): MessageType {
                                return this._b
                            }

                            set b(b: MessageType) {
                                this._b = b
                            }

                            private _c: string[];

                            get c(): string[] {
                                return this._c
                            }

                            set c(c: string[]) {
                                this._c = c
                            }

                            private _e: SecondExampleMessage;

                            get e(): SecondExampleMessage {
                                return this._e
                            }

                            set e(e: SecondExampleMessage) {
                                this._e = e
                            }

                            private _d: Map<string, string>;

                            get d(): Map<string, string> {
                                return this._d
                            }

                            set d(d: Map<string, string>) {
                                this._d = d
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._a)
                                encoded = encodeUint8(encoded, this._b as number)
                                encoded = encodeArray(encoded, this._c.length, Kind.String)
                                this._c.forEach(field => {
                                                  encoded = encodeString(encoded, field);
                                                })
                                encoded = this._e.encode(encoded)
                                encoded = encodeMap(encoded, this._d.size,
                                              Kind.String,
                                              Kind.String)
                                this._d.forEach((value, key) => {
                                                  encoded = encodeString(encoded, key);
                                                  encoded = encodeString(encoded, value);
                                                })
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: ExampleMessage
                                    } {
                                let decoded = buf
                                const aTemp = decodeString(decoded)
                                decoded = aTemp.buf
                                const bUint8 = decodeUint8(decoded)
                                const bTemp = { value: bUint8.value as MessageType }

                                decoded = bUint8.buf
                                const cArray = decodeArray(decoded)
                                decoded = cArray.buf
                                const cTemp: { value: string[] } = {
                                                  value: [],
                                                }

                                for (let i = 0; i < cArray.size; i++) {
                                                  const element = decodeString(decoded);
                                                  decoded = element.buf;
                                                  cTemp.value.push(element.value);
                                                }

                                const eTemp = SecondExampleMessage.decode(decoded)
                                decoded = eTemp.buf
                                const dMap = decodeMap(decoded)
                                decoded = dMap.buf
                                const d: { value: Map<string, string> } = {
                                                  value: new Map<string, string>(),
                                                }

                                for (let i = 0; i < dMap.size; i++) {
                                                  const key = decodeString(decoded);
                                                  decoded = key.buf;
                                                  const value = decodeString(decoded);
                                                  decoded = value.buf;
                                                  dTemp.value.set(key.value, value.value);
                                                }

                                return {
                                      buf: decoded,
                                      value: new ExampleMessage(aTemp.value,bTemp.value,cTemp.value,eTemp.value,dTemp.value)
                                    }
                            }
                        }

                        export class SecondExampleMessage {
                            constructor(a: string) {
                                this._a = a
                            }

                            private _a: string;

                            get a(): string {
                                return this._a
                            }

                            set a(a: string) {
                                this._a = a
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._a)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: SecondExampleMessage
                                    } {
                                let decoded = buf
                                const aTemp = decodeString(decoded)
                                decoded = aTemp.buf
                                return {
                                      buf: decoded,
                                      value: new SecondExampleMessage(aTemp.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for rpc.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace rpc {
                        export class ExampleMessage {
                            constructor(a: string) {
                                this._a = a
                            }

                            private _a: string;

                            get a(): string {
                                return this._a
                            }

                            set a(a: string) {
                                this._a = a
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._a)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: ExampleMessage
                                    } {
                                let decoded = buf
                                const aTemp = decodeString(decoded)
                                decoded = aTemp.buf
                                return {
                                      buf: decoded,
                                      value: new ExampleMessage(aTemp.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for simple.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt32, decodeInt32 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace simple {
                        export class User {
                            constructor(name: string, age: number, department: Department) {
                                this._name = name
                                this._age = age
                                this._department = department
                            }

                            private _name: string;

                            get name(): string {
                                return this._name
                            }

                            set name(name: string) {
                                this._name = name
                            }

                            private _age: number;

                            get age(): number {
                                return this._age
                            }

                            set age(age: number) {
                                this._age = age
                            }

                            private _department: Department;

                            get department(): Department {
                                return this._department
                            }

                            set department(department: Department) {
                                this._department = department
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._name)
                                encoded = encodeInt32(encoded, this._age)
                                encoded = this._department.encode(encoded)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: User
                                    } {
                                let decoded = buf
                                const nameTemp = decodeString(decoded)
                                decoded = nameTemp.buf
                                const ageTemp = decodeInt32(decoded)
                                decoded = ageTemp.buf
                                const departmentTemp = Department.decode(decoded)
                                decoded = departmentTemp.buf
                                return {
                                      buf: decoded,
                                      value: new User(nameTemp.value,ageTemp.value,departmentTemp.value)
                                    }
                            }
                        }

                        export class Department {
                            constructor(name: string) {
                                this._name = name
                            }

                            private _name: string;

                            get name(): string {
                                return this._name
                            }

                            set name(name: string) {
                                this._name = name
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._name)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: Department
                                    } {
                                let decoded = buf
                                const nameTemp = decodeString(decoded)
                                decoded = nameTemp.buf
                                return {
                                      buf: decoded,
                                      value: new Department(nameTemp.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;

exports[`Generator Can generate TypeScript for simple_hoisted.proto 1`] = `
"// Code generated by protoc-gen-ts-polyglot 0.3.0. DO NOT EDIT.
import { encodeString, decodeString, encodeInt32, decodeInt32 } from \\"polyglot-ts\\";

export namespace io {
    export namespace loopholelabs {
        export namespace polyglot {
            export namespace test {
                export namespace data {
                    export namespace simple {
                        export class Department {
                            constructor(name: string) {
                                this._name = name
                            }

                            private _name: string;

                            get name(): string {
                                return this._name
                            }

                            set name(name: string) {
                                this._name = name
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._name)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: Department
                                    } {
                                let decoded = buf
                                const nameTemp = decodeString(decoded)
                                decoded = nameTemp.buf
                                return {
                                      buf: decoded,
                                      value: new Department(nameTemp.value)
                                    }
                            }
                        }

                        export class User {
                            constructor(name: string, age: number, department: Department) {
                                this._name = name
                                this._age = age
                                this._department = department
                            }

                            private _name: string;

                            get name(): string {
                                return this._name
                            }

                            set name(name: string) {
                                this._name = name
                            }

                            private _age: number;

                            get age(): number {
                                return this._age
                            }

                            set age(age: number) {
                                this._age = age
                            }

                            private _department: Department;

                            get department(): Department {
                                return this._department
                            }

                            set department(department: Department) {
                                this._department = department
                            }

                            encode(buf: Uint8Array): Uint8Array {
                                let encoded = buf
                                encoded = encodeString(encoded, this._name)
                                encoded = encodeInt32(encoded, this._age)
                                encoded = this._department.encode(encoded)
                                return encoded
                            }

                            static decode(buf: Uint8Array): {
                                      buf: Uint8Array,
                                      value: User
                                    } {
                                let decoded = buf
                                const nameTemp = decodeString(decoded)
                                decoded = nameTemp.buf
                                const ageTemp = decodeInt32(decoded)
                                decoded = ageTemp.buf
                                const departmentTemp = Department.decode(decoded)
                                decoded = departmentTemp.buf
                                return {
                                      buf: decoded,
                                      value: new User(nameTemp.value,ageTemp.value,departmentTemp.value)
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}
"
`;
